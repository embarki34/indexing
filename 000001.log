/* 2025-03-27 08:26:37 [postgress] */ [08:26:37.321] SELECT NOW();
/* 2025-03-27 08:26:37 [postgress] */ [08:26:37.325] SELECT 'citext'::regtype::oid;
/* 2025-03-27 08:26:37 [postgress] */ [08:26:37.328] SELECT VERSION();
/* 2025-03-27 08:26:37 [postgress] */ [08:26:37.329] SET statement_timeout TO 30000;
/* 2025-03-27 08:26:37 [postgress] */ [08:26:37.330] SELECT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP - pg_postmaster_start_time())::INTEGER;
/* 2025-03-27 08:26:37 [postgress] */ [08:26:37.336] SHOW ssl;
/* 2025-03-27 08:26:37 [postgress] */ [08:26:37.356] SELECT table_name FROM information_schema.tables WHERE table_schema='information_schema';
/* 2025-03-27 08:26:37 [postgress] */ [08:26:37.370] SELECT "nspname" FROM "pg_catalog"."pg_namespace" ORDER BY "nspname";
/* 2025-03-27 08:26:49 [postgress] */ [08:26:49.719] SET search_path TO 'public', '$user';
/* 2025-03-27 08:26:51 [postgress] */ [08:26:51.852] SELECT *, pg_table_size(QUOTE_IDENT(t.TABLE_SCHEMA) || '.' || QUOTE_IDENT(t.TABLE_NAME))::bigint AS data_length, pg_relation_size(QUOTE_IDENT(t.TABLE_SCHEMA) || '.' || QUOTE_IDENT(t.TABLE_NAME))::bigint AS index_length, c.reltuples, obj_description(c.oid) AS comment FROM "information_schema"."tables" AS t LEFT JOIN "pg_namespace" n ON t.table_schema = n.nspname LEFT JOIN "pg_class" c ON n.oid = c.relnamespace AND c.relname=t.table_name WHERE t."table_schema"='public';
/* 2025-03-27 08:26:51 [postgress] */ [08:26:51.869] SELECT "p"."proname", "p"."proargtypes" FROM "pg_catalog"."pg_namespace" AS "n" JOIN "pg_catalog"."pg_proc" AS "p" ON "p"."pronamespace" = "n"."oid" WHERE "n"."nspname"='public';
/* 2025-03-27 08:26:52 [postgress] */ [08:26:52.894] SELECT * FROM "information_schema"."columns" WHERE TABLE_SCHEMA='public' AND TABLE_NAME='categories' ORDER BY ORDINAL_POSITION;
/* 2025-03-27 08:26:52 [postgress] */ [08:26:52.913] SELECT a.attname AS column, des.description AS comment FROM pg_attribute AS a, pg_description AS des, pg_class AS pgc WHERE     pgc.oid = a.attrelid     AND des.objoid = pgc.oid     AND pg_table_is_visible(pgc.oid)     AND pgc.relname = 'categories'     AND a.attnum = des.objsubid;
/* 2025-03-27 08:26:52 [postgress] */ [08:26:52.915] WITH ndx_list AS (    SELECT pg_index.indexrelid, pg_class.oid    FROM pg_index, pg_class    WHERE pg_class.relname = 'categories'    AND pg_class.oid = pg_index.indrelid  ),  ndx_cols AS (    SELECT pg_class.relname, UNNEST(i.indkey) AS col_ndx,    CASE i.indisprimary WHEN true THEN 'PRIMARY' ELSE CASE i.indisunique WHEN true THEN 'UNIQUE' ELSE 'KEY' END END AS CONSTRAINT_TYPE,    pg_class.oid    FROM pg_class    JOIN pg_index i ON (pg_class.oid = i.indexrelid)    JOIN ndx_list ON (pg_class.oid = ndx_list.indexrelid)    WHERE pg_table_is_visible(pg_class.oid)  )SELECT ndx_cols.relname AS CONSTRAINT_NAME, ndx_cols.CONSTRAINT_TYPE, a.attname AS COLUMN_NAME FROM pg_attribute a JOIN ndx_cols ON (a.attnum = ndx_cols.col_ndx) JOIN ndx_list ON (ndx_list.oid = a.attrelid AND ndx_list.indexrelid = ndx_cols.oid);
/* 2025-03-27 08:26:52 [postgress] */ [08:26:52.918] SELECT   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   STRING_AGG(distinct kcu.column_name, ',') AS columns,   ccu.table_schema AS ref_schema,   ccu.table_name AS ref_table,   STRING_AGG(distinct ccu.column_name, ',') AS ref_columns,   STRING_AGG(distinct kcu.ordinal_position::text, ',') AS ord_position FROM   information_schema.referential_constraints AS refc,   information_schema.key_column_usage AS kcu,   information_schema.constraint_column_usage AS ccu WHERE   refc.constraint_schema = 'public'   AND kcu.table_name = 'categories'   AND kcu.constraint_name = refc.constraint_name   AND kcu.table_schema = refc.constraint_schema   AND ccu.constraint_name = refc.constraint_name   AND ccu.constraint_schema = refc.constraint_schema GROUP BY   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   ccu.table_schema,   ccu.table_name ORDER BY   ord_position;
/* 2025-03-27 08:26:53 [postgress] */ [08:26:53.001] SELECT tc.CONSTRAINT_NAME, cc.CHECK_CLAUSE FROM "information_schema"."check_constraints" AS cc, "information_schema"."table_constraints" AS tc WHERE tc.CONSTRAINT_SCHEMA='public' AND tc.TABLE_NAME='categories' AND tc.CONSTRAINT_TYPE='CHECK' AND tc.CONSTRAINT_SCHEMA=cc.CONSTRAINT_SCHEMA AND tc.CONSTRAINT_NAME=cc.CONSTRAINT_NAME AND cc.CONSTRAINT_NAME NOT LIKE '%\_not\_null';
/* 2025-03-27 08:26:53 [postgress] */ [08:26:53.542] SELECT * FROM "information_schema"."columns" WHERE TABLE_SCHEMA='public' AND TABLE_NAME='orderitems' ORDER BY ORDINAL_POSITION;
/* 2025-03-27 08:26:53 [postgress] */ [08:26:53.550] SELECT a.attname AS column, des.description AS comment FROM pg_attribute AS a, pg_description AS des, pg_class AS pgc WHERE     pgc.oid = a.attrelid     AND des.objoid = pgc.oid     AND pg_table_is_visible(pgc.oid)     AND pgc.relname = 'orderitems'     AND a.attnum = des.objsubid;
/* 2025-03-27 08:26:53 [postgress] */ [08:26:53.551] WITH ndx_list AS (    SELECT pg_index.indexrelid, pg_class.oid    FROM pg_index, pg_class    WHERE pg_class.relname = 'orderitems'    AND pg_class.oid = pg_index.indrelid  ),  ndx_cols AS (    SELECT pg_class.relname, UNNEST(i.indkey) AS col_ndx,    CASE i.indisprimary WHEN true THEN 'PRIMARY' ELSE CASE i.indisunique WHEN true THEN 'UNIQUE' ELSE 'KEY' END END AS CONSTRAINT_TYPE,    pg_class.oid    FROM pg_class    JOIN pg_index i ON (pg_class.oid = i.indexrelid)    JOIN ndx_list ON (pg_class.oid = ndx_list.indexrelid)    WHERE pg_table_is_visible(pg_class.oid)  )SELECT ndx_cols.relname AS CONSTRAINT_NAME, ndx_cols.CONSTRAINT_TYPE, a.attname AS COLUMN_NAME FROM pg_attribute a JOIN ndx_cols ON (a.attnum = ndx_cols.col_ndx) JOIN ndx_list ON (ndx_list.oid = a.attrelid AND ndx_list.indexrelid = ndx_cols.oid);
/* 2025-03-27 08:26:53 [postgress] */ [08:26:53.554] SELECT   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   STRING_AGG(distinct kcu.column_name, ',') AS columns,   ccu.table_schema AS ref_schema,   ccu.table_name AS ref_table,   STRING_AGG(distinct ccu.column_name, ',') AS ref_columns,   STRING_AGG(distinct kcu.ordinal_position::text, ',') AS ord_position FROM   information_schema.referential_constraints AS refc,   information_schema.key_column_usage AS kcu,   information_schema.constraint_column_usage AS ccu WHERE   refc.constraint_schema = 'public'   AND kcu.table_name = 'orderitems'   AND kcu.constraint_name = refc.constraint_name   AND kcu.table_schema = refc.constraint_schema   AND ccu.constraint_name = refc.constraint_name   AND ccu.constraint_schema = refc.constraint_schema GROUP BY   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   ccu.table_schema,   ccu.table_name ORDER BY   ord_position;
/* 2025-03-27 08:26:53 [postgress] */ [08:26:53.565] SELECT tc.CONSTRAINT_NAME, cc.CHECK_CLAUSE FROM "information_schema"."check_constraints" AS cc, "information_schema"."table_constraints" AS tc WHERE tc.CONSTRAINT_SCHEMA='public' AND tc.TABLE_NAME='orderitems' AND tc.CONSTRAINT_TYPE='CHECK' AND tc.CONSTRAINT_SCHEMA=cc.CONSTRAINT_SCHEMA AND tc.CONSTRAINT_NAME=cc.CONSTRAINT_NAME AND cc.CONSTRAINT_NAME NOT LIKE '%\_not\_null';
/* 2025-03-27 08:26:54 [postgress] */ [08:26:53.996] SELECT * FROM "information_schema"."columns" WHERE TABLE_SCHEMA='public' AND TABLE_NAME='orders' ORDER BY ORDINAL_POSITION;
/* 2025-03-27 08:26:54 [postgress] */ [08:26:54.016] SELECT a.attname AS column, des.description AS comment FROM pg_attribute AS a, pg_description AS des, pg_class AS pgc WHERE     pgc.oid = a.attrelid     AND des.objoid = pgc.oid     AND pg_table_is_visible(pgc.oid)     AND pgc.relname = 'orders'     AND a.attnum = des.objsubid;
/* 2025-03-27 08:26:54 [postgress] */ [08:26:54.026] WITH ndx_list AS (    SELECT pg_index.indexrelid, pg_class.oid    FROM pg_index, pg_class    WHERE pg_class.relname = 'orders'    AND pg_class.oid = pg_index.indrelid  ),  ndx_cols AS (    SELECT pg_class.relname, UNNEST(i.indkey) AS col_ndx,    CASE i.indisprimary WHEN true THEN 'PRIMARY' ELSE CASE i.indisunique WHEN true THEN 'UNIQUE' ELSE 'KEY' END END AS CONSTRAINT_TYPE,    pg_class.oid    FROM pg_class    JOIN pg_index i ON (pg_class.oid = i.indexrelid)    JOIN ndx_list ON (pg_class.oid = ndx_list.indexrelid)    WHERE pg_table_is_visible(pg_class.oid)  )SELECT ndx_cols.relname AS CONSTRAINT_NAME, ndx_cols.CONSTRAINT_TYPE, a.attname AS COLUMN_NAME FROM pg_attribute a JOIN ndx_cols ON (a.attnum = ndx_cols.col_ndx) JOIN ndx_list ON (ndx_list.oid = a.attrelid AND ndx_list.indexrelid = ndx_cols.oid);
/* 2025-03-27 08:26:54 [postgress] */ [08:26:54.037] SELECT   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   STRING_AGG(distinct kcu.column_name, ',') AS columns,   ccu.table_schema AS ref_schema,   ccu.table_name AS ref_table,   STRING_AGG(distinct ccu.column_name, ',') AS ref_columns,   STRING_AGG(distinct kcu.ordinal_position::text, ',') AS ord_position FROM   information_schema.referential_constraints AS refc,   information_schema.key_column_usage AS kcu,   information_schema.constraint_column_usage AS ccu WHERE   refc.constraint_schema = 'public'   AND kcu.table_name = 'orders'   AND kcu.constraint_name = refc.constraint_name   AND kcu.table_schema = refc.constraint_schema   AND ccu.constraint_name = refc.constraint_name   AND ccu.constraint_schema = refc.constraint_schema GROUP BY   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   ccu.table_schema,   ccu.table_name ORDER BY   ord_position;
/* 2025-03-27 08:26:54 [postgress] */ [08:26:54.054] SELECT tc.CONSTRAINT_NAME, cc.CHECK_CLAUSE FROM "information_schema"."check_constraints" AS cc, "information_schema"."table_constraints" AS tc WHERE tc.CONSTRAINT_SCHEMA='public' AND tc.TABLE_NAME='orders' AND tc.CONSTRAINT_TYPE='CHECK' AND tc.CONSTRAINT_SCHEMA=cc.CONSTRAINT_SCHEMA AND tc.CONSTRAINT_NAME=cc.CONSTRAINT_NAME AND cc.CONSTRAINT_NAME NOT LIKE '%\_not\_null';
/* 2025-03-27 08:26:54 [postgress] */ [08:26:54.703] SELECT * FROM "information_schema"."columns" WHERE TABLE_SCHEMA='public' AND TABLE_NAME='products' ORDER BY ORDINAL_POSITION;
/* 2025-03-27 08:26:54 [postgress] */ [08:26:54.720] SELECT a.attname AS column, des.description AS comment FROM pg_attribute AS a, pg_description AS des, pg_class AS pgc WHERE     pgc.oid = a.attrelid     AND des.objoid = pgc.oid     AND pg_table_is_visible(pgc.oid)     AND pgc.relname = 'products'     AND a.attnum = des.objsubid;
/* 2025-03-27 08:26:54 [postgress] */ [08:26:54.732] WITH ndx_list AS (    SELECT pg_index.indexrelid, pg_class.oid    FROM pg_index, pg_class    WHERE pg_class.relname = 'products'    AND pg_class.oid = pg_index.indrelid  ),  ndx_cols AS (    SELECT pg_class.relname, UNNEST(i.indkey) AS col_ndx,    CASE i.indisprimary WHEN true THEN 'PRIMARY' ELSE CASE i.indisunique WHEN true THEN 'UNIQUE' ELSE 'KEY' END END AS CONSTRAINT_TYPE,    pg_class.oid    FROM pg_class    JOIN pg_index i ON (pg_class.oid = i.indexrelid)    JOIN ndx_list ON (pg_class.oid = ndx_list.indexrelid)    WHERE pg_table_is_visible(pg_class.oid)  )SELECT ndx_cols.relname AS CONSTRAINT_NAME, ndx_cols.CONSTRAINT_TYPE, a.attname AS COLUMN_NAME FROM pg_attribute a JOIN ndx_cols ON (a.attnum = ndx_cols.col_ndx) JOIN ndx_list ON (ndx_list.oid = a.attrelid AND ndx_list.indexrelid = ndx_cols.oid);
/* 2025-03-27 08:26:54 [postgress] */ [08:26:54.744] SELECT   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   STRING_AGG(distinct kcu.column_name, ',') AS columns,   ccu.table_schema AS ref_schema,   ccu.table_name AS ref_table,   STRING_AGG(distinct ccu.column_name, ',') AS ref_columns,   STRING_AGG(distinct kcu.ordinal_position::text, ',') AS ord_position FROM   information_schema.referential_constraints AS refc,   information_schema.key_column_usage AS kcu,   information_schema.constraint_column_usage AS ccu WHERE   refc.constraint_schema = 'public'   AND kcu.table_name = 'products'   AND kcu.constraint_name = refc.constraint_name   AND kcu.table_schema = refc.constraint_schema   AND ccu.constraint_name = refc.constraint_name   AND ccu.constraint_schema = refc.constraint_schema GROUP BY   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   ccu.table_schema,   ccu.table_name ORDER BY   ord_position;
/* 2025-03-27 08:26:54 [postgress] */ [08:26:54.763] SELECT tc.CONSTRAINT_NAME, cc.CHECK_CLAUSE FROM "information_schema"."check_constraints" AS cc, "information_schema"."table_constraints" AS tc WHERE tc.CONSTRAINT_SCHEMA='public' AND tc.TABLE_NAME='products' AND tc.CONSTRAINT_TYPE='CHECK' AND tc.CONSTRAINT_SCHEMA=cc.CONSTRAINT_SCHEMA AND tc.CONSTRAINT_NAME=cc.CONSTRAINT_NAME AND cc.CONSTRAINT_NAME NOT LIKE '%\_not\_null';
/* 2025-03-27 08:26:55 [postgress] */ [08:26:55.346] SELECT * FROM "information_schema"."columns" WHERE TABLE_SCHEMA='public' AND TABLE_NAME='users' ORDER BY ORDINAL_POSITION;
/* 2025-03-27 08:26:55 [postgress] */ [08:26:55.364] SELECT a.attname AS column, des.description AS comment FROM pg_attribute AS a, pg_description AS des, pg_class AS pgc WHERE     pgc.oid = a.attrelid     AND des.objoid = pgc.oid     AND pg_table_is_visible(pgc.oid)     AND pgc.relname = 'users'     AND a.attnum = des.objsubid;
/* 2025-03-27 08:26:55 [postgress] */ [08:26:55.376] WITH ndx_list AS (    SELECT pg_index.indexrelid, pg_class.oid    FROM pg_index, pg_class    WHERE pg_class.relname = 'users'    AND pg_class.oid = pg_index.indrelid  ),  ndx_cols AS (    SELECT pg_class.relname, UNNEST(i.indkey) AS col_ndx,    CASE i.indisprimary WHEN true THEN 'PRIMARY' ELSE CASE i.indisunique WHEN true THEN 'UNIQUE' ELSE 'KEY' END END AS CONSTRAINT_TYPE,    pg_class.oid    FROM pg_class    JOIN pg_index i ON (pg_class.oid = i.indexrelid)    JOIN ndx_list ON (pg_class.oid = ndx_list.indexrelid)    WHERE pg_table_is_visible(pg_class.oid)  )SELECT ndx_cols.relname AS CONSTRAINT_NAME, ndx_cols.CONSTRAINT_TYPE, a.attname AS COLUMN_NAME FROM pg_attribute a JOIN ndx_cols ON (a.attnum = ndx_cols.col_ndx) JOIN ndx_list ON (ndx_list.oid = a.attrelid AND ndx_list.indexrelid = ndx_cols.oid);
/* 2025-03-27 08:26:55 [postgress] */ [08:26:55.389] SELECT   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   STRING_AGG(distinct kcu.column_name, ',') AS columns,   ccu.table_schema AS ref_schema,   ccu.table_name AS ref_table,   STRING_AGG(distinct ccu.column_name, ',') AS ref_columns,   STRING_AGG(distinct kcu.ordinal_position::text, ',') AS ord_position FROM   information_schema.referential_constraints AS refc,   information_schema.key_column_usage AS kcu,   information_schema.constraint_column_usage AS ccu WHERE   refc.constraint_schema = 'public'   AND kcu.table_name = 'users'   AND kcu.constraint_name = refc.constraint_name   AND kcu.table_schema = refc.constraint_schema   AND ccu.constraint_name = refc.constraint_name   AND ccu.constraint_schema = refc.constraint_schema GROUP BY   refc.constraint_name,   refc.update_rule,   refc.delete_rule,   kcu.table_name,   ccu.table_schema,   ccu.table_name ORDER BY   ord_position;
/* 2025-03-27 08:26:55 [postgress] */ [08:26:55.407] SELECT tc.CONSTRAINT_NAME, cc.CHECK_CLAUSE FROM "information_schema"."check_constraints" AS cc, "information_schema"."table_constraints" AS tc WHERE tc.CONSTRAINT_SCHEMA='public' AND tc.TABLE_NAME='users' AND tc.CONSTRAINT_TYPE='CHECK' AND tc.CONSTRAINT_SCHEMA=cc.CONSTRAINT_SCHEMA AND tc.CONSTRAINT_NAME=cc.CONSTRAINT_NAME AND cc.CONSTRAINT_NAME NOT LIKE '%\_not\_null';
/* 2025-03-27 08:26:58 [postgress] */ [08:26:58.649] SELECT  "user_id",  "first_name",  "last_name",  "email",  "password",  "phone_number", SUBSTRING("shipping_address", 1, 256),  "created_at",  "updated_at" FROM "public"."users" LIMIT 1000;
/* 2025-03-27 08:27:00 [postgress] */ [08:27:00.135] SELECT  "product_id",  "name", SUBSTRING("description", 1, 256),  "price",  "stock_quantity",  "category_id",  "created_at",  "updated_at" FROM "public"."products" LIMIT 1000;
/* 2025-03-27 08:27:01 [postgress] */ [08:27:01.769] SELECT * FROM "public"."orderitems" LIMIT 1000;
/* 2025-03-27 08:27:02 [postgress] */ [08:27:02.584] SELECT  "category_id",  "name", SUBSTRING("description", 1, 256),  "created_at",  "updated_at" FROM "public"."categories" LIMIT 1000;
/* 2025-03-27 08:27:10 [postgress] */ [08:27:10.023] SELECT * FROM "public"."orderitems" LIMIT 1000;
/* 2025-03-27 08:27:12 [postgress] */ [08:27:12.797] SELECT  "category_id",  "name", SUBSTRING("description", 1, 256),  "created_at",  "updated_at" FROM "public"."categories" LIMIT 1000;
/* 2025-03-27 08:28:21 [postgress] */ [08:28:21.003] SELECT  "order_id",  "user_id",  "order_date",  "status",  "total_amount", SUBSTRING("shipping_address", 1, 256) FROM "public"."orders" LIMIT 1000;
/* 2025-03-27 08:28:43 [postgress] */ [08:28:43.628] SELECT 16407::regclass;
