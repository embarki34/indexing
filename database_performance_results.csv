query_name,index_type,query,index_description,index_statement,execution_time,cpu_start,cpu_end,cpu_change,memory_start,memory_end,memory_change,result_count,select,insert,update,delete,create,drop,alter,join,where,group by,order by,having,limit,between,in,like,error
category_performance,btree,"SELECT c.name as category_name, DATE_TRUNC('month', o.order_date) as month, COUNT(DISTINCT o.order_id) as total_orders, SUM(oi.quantity) as items_sold, SUM(oi.quantity * oi.price) as revenue FROM categories c JOIN products p ON c.category_id = p.category_id JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id GROUP BY c.name, month ORDER BY c.name, month;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),1.6149663925170898,0.0,0.0,0.0,79.36328125,80.44140625,1.078125,2160,1,0,0,0,0,0,0,3,0,1,1,0,0,0,4,0,
category_performance_hash,hash,"SELECT c.name as category_name, DATE_TRUNC('month', o.order_date) as month, COUNT(DISTINCT o.order_id) as total_orders, SUM(oi.quantity) as items_sold, SUM(oi.quantity * oi.price) as revenue FROM categories c JOIN products p ON c.category_id = p.category_id JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id GROUP BY c.name, month ORDER BY c.name, month;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),1.5433320999145508,0.0,0.0,0.0,80.4453125,80.4609375,0.015625,2160,1,0,0,0,0,0,0,3,0,1,1,0,0,0,4,0,
category_performance_bitmap,bitmap,"SELECT c.name as category_name, DATE_TRUNC('month', o.order_date) as month, COUNT(DISTINCT o.order_id) as total_orders, SUM(oi.quantity) as items_sold, SUM(oi.quantity * oi.price) as revenue FROM categories c JOIN products p ON c.category_id = p.category_id JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id GROUP BY c.name, month ORDER BY c.name, month;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),1.522991418838501,0.0,0.0,0.0,80.4609375,80.47265625,0.01171875,2160,1,0,0,0,0,0,0,3,0,1,1,0,0,0,4,0,
category_performance_gist,gist,"SELECT c.name as category_name, DATE_TRUNC('month', o.order_date) as month, COUNT(DISTINCT o.order_id) as total_orders, SUM(oi.quantity) as items_sold, SUM(oi.quantity * oi.price) as revenue FROM categories c JOIN products p ON c.category_id = p.category_id JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id GROUP BY c.name, month ORDER BY c.name, month;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),1.5266356468200684,0.0,0.0,0.0,80.47265625,80.47265625,0.0,2160,1,0,0,0,0,0,0,3,0,1,1,0,0,0,4,0,
category_performance_reverse,reverse,"SELECT c.name as category_name, DATE_TRUNC('month', o.order_date) as month, COUNT(DISTINCT o.order_id) as total_orders, SUM(oi.quantity) as items_sold, SUM(oi.quantity * oi.price) as revenue FROM categories c JOIN products p ON c.category_id = p.category_id JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id GROUP BY c.name, month ORDER BY c.name, month;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),1.5947396755218506,0.0,0.0,0.0,80.47265625,80.4765625,0.00390625,2160,1,0,0,0,0,0,0,3,0,1,1,0,0,0,4,0,
customer_order_trends,btree,"SELECT u.user_id, DATE_TRUNC('month', o.order_date) as month, COUNT(o.order_id) as orders_per_month, AVG(o.total_amount) as avg_order_value, SUM(oi.quantity) as total_items FROM users u JOIN orders o ON u.user_id = o.user_id JOIN orderitems oi ON o.order_id = oi.order_id GROUP BY u.user_id, month ORDER BY u.user_id, month;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),1.3519573211669922,0.0,0.0,0.0,80.4765625,197.578125,117.1015625,276934,1,0,0,0,0,0,0,2,0,1,1,0,0,0,2,0,
customer_order_trends_hash,hash,"SELECT u.user_id, DATE_TRUNC('month', o.order_date) as month, COUNT(o.order_id) as orders_per_month, AVG(o.total_amount) as avg_order_value, SUM(oi.quantity) as total_items FROM users u JOIN orders o ON u.user_id = o.user_id JOIN orderitems oi ON o.order_id = oi.order_id GROUP BY u.user_id, month ORDER BY u.user_id, month;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),1.3709697723388672,0.0,0.0,0.0,83.22265625,197.234375,114.01171875,276934,1,0,0,0,0,0,0,2,0,1,1,0,0,0,2,0,
customer_order_trends_bitmap,bitmap,"SELECT u.user_id, DATE_TRUNC('month', o.order_date) as month, COUNT(o.order_id) as orders_per_month, AVG(o.total_amount) as avg_order_value, SUM(oi.quantity) as total_items FROM users u JOIN orders o ON u.user_id = o.user_id JOIN orderitems oi ON o.order_id = oi.order_id GROUP BY u.user_id, month ORDER BY u.user_id, month;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),1.392876148223877,0.0,0.0,0.0,85.12109375,197.37109375,112.25,276934,1,0,0,0,0,0,0,2,0,1,1,0,0,0,2,0,
customer_order_trends_gist,gist,"SELECT u.user_id, DATE_TRUNC('month', o.order_date) as month, COUNT(o.order_id) as orders_per_month, AVG(o.total_amount) as avg_order_value, SUM(oi.quantity) as total_items FROM users u JOIN orders o ON u.user_id = o.user_id JOIN orderitems oi ON o.order_id = oi.order_id GROUP BY u.user_id, month ORDER BY u.user_id, month;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),1.3291075229644775,0.0,0.0,0.0,86.28125,197.46875,111.1875,276934,1,0,0,0,0,0,0,2,0,1,1,0,0,0,2,0,
customer_order_trends_reverse,reverse,"SELECT u.user_id, DATE_TRUNC('month', o.order_date) as month, COUNT(o.order_id) as orders_per_month, AVG(o.total_amount) as avg_order_value, SUM(oi.quantity) as total_items FROM users u JOIN orders o ON u.user_id = o.user_id JOIN orderitems oi ON o.order_id = oi.order_id GROUP BY u.user_id, month ORDER BY u.user_id, month;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),1.3945586681365967,0.0,0.0,0.0,87.55859375,197.28515625,109.7265625,276934,1,0,0,0,0,0,0,2,0,1,1,0,0,0,2,0,
customer_segmentation,btree,"SELECT u.user_id, u.email, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS total_spent, AVG(o.total_amount) AS avg_order_value, EXTRACT(DAY FROM AGE(MAX(o.order_date), MIN(o.order_date))) / NULLIF(COUNT(o.order_id), 0) AS avg_days_between_orders, CASE WHEN COUNT(o.order_id) > 10 AND SUM(o.total_amount) > 5000 THEN 'Premium' WHEN COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 2000 THEN 'Gold' WHEN COUNT(o.order_id) > 2 AND SUM(o.total_amount) > 1000 THEN 'Silver' ELSE 'Bronze' END AS customer_segment, DENSE_RANK() OVER (ORDER BY SUM(o.total_amount) DESC) AS spending_rank, MAX(o.order_date) AS last_order_date, EXTRACT(DAY FROM AGE(CURRENT_DATE, MAX(o.order_date))) AS days_since_last_order FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email HAVING COUNT(o.order_id) > 0 ORDER BY total_spent DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.47553181648254395,0.0,0.0,0.0,89.1796875,91.921875,2.7421875,10000,1,0,0,0,0,0,0,1,0,1,2,1,0,1,6,0,
customer_segmentation_hash,hash,"SELECT u.user_id, u.email, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS total_spent, AVG(o.total_amount) AS avg_order_value, EXTRACT(DAY FROM AGE(MAX(o.order_date), MIN(o.order_date))) / NULLIF(COUNT(o.order_id), 0) AS avg_days_between_orders, CASE WHEN COUNT(o.order_id) > 10 AND SUM(o.total_amount) > 5000 THEN 'Premium' WHEN COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 2000 THEN 'Gold' WHEN COUNT(o.order_id) > 2 AND SUM(o.total_amount) > 1000 THEN 'Silver' ELSE 'Bronze' END AS customer_segment, DENSE_RANK() OVER (ORDER BY SUM(o.total_amount) DESC) AS spending_rank, MAX(o.order_date) AS last_order_date, EXTRACT(DAY FROM AGE(CURRENT_DATE, MAX(o.order_date))) AS days_since_last_order FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email HAVING COUNT(o.order_id) > 0 ORDER BY total_spent DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.422990083694458,0.0,0.0,0.0,89.40234375,91.30078125,1.8984375,10000,1,0,0,0,0,0,0,1,0,1,2,1,0,1,6,0,
customer_segmentation_bitmap,bitmap,"SELECT u.user_id, u.email, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS total_spent, AVG(o.total_amount) AS avg_order_value, EXTRACT(DAY FROM AGE(MAX(o.order_date), MIN(o.order_date))) / NULLIF(COUNT(o.order_id), 0) AS avg_days_between_orders, CASE WHEN COUNT(o.order_id) > 10 AND SUM(o.total_amount) > 5000 THEN 'Premium' WHEN COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 2000 THEN 'Gold' WHEN COUNT(o.order_id) > 2 AND SUM(o.total_amount) > 1000 THEN 'Silver' ELSE 'Bronze' END AS customer_segment, DENSE_RANK() OVER (ORDER BY SUM(o.total_amount) DESC) AS spending_rank, MAX(o.order_date) AS last_order_date, EXTRACT(DAY FROM AGE(CURRENT_DATE, MAX(o.order_date))) AS days_since_last_order FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email HAVING COUNT(o.order_id) > 0 ORDER BY total_spent DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.42420387268066406,0.0,0.0,0.0,89.64453125,91.265625,1.62109375,10000,1,0,0,0,0,0,0,1,0,1,2,1,0,1,6,0,
customer_segmentation_gist,gist,"SELECT u.user_id, u.email, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS total_spent, AVG(o.total_amount) AS avg_order_value, EXTRACT(DAY FROM AGE(MAX(o.order_date), MIN(o.order_date))) / NULLIF(COUNT(o.order_id), 0) AS avg_days_between_orders, CASE WHEN COUNT(o.order_id) > 10 AND SUM(o.total_amount) > 5000 THEN 'Premium' WHEN COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 2000 THEN 'Gold' WHEN COUNT(o.order_id) > 2 AND SUM(o.total_amount) > 1000 THEN 'Silver' ELSE 'Bronze' END AS customer_segment, DENSE_RANK() OVER (ORDER BY SUM(o.total_amount) DESC) AS spending_rank, MAX(o.order_date) AS last_order_date, EXTRACT(DAY FROM AGE(CURRENT_DATE, MAX(o.order_date))) AS days_since_last_order FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email HAVING COUNT(o.order_id) > 0 ORDER BY total_spent DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.4169578552246094,0.0,0.0,0.0,89.48828125,91.41015625,1.921875,10000,1,0,0,0,0,0,0,1,0,1,2,1,0,1,6,0,
customer_segmentation_reverse,reverse,"SELECT u.user_id, u.email, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS total_spent, AVG(o.total_amount) AS avg_order_value, EXTRACT(DAY FROM AGE(MAX(o.order_date), MIN(o.order_date))) / NULLIF(COUNT(o.order_id), 0) AS avg_days_between_orders, CASE WHEN COUNT(o.order_id) > 10 AND SUM(o.total_amount) > 5000 THEN 'Premium' WHEN COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 2000 THEN 'Gold' WHEN COUNT(o.order_id) > 2 AND SUM(o.total_amount) > 1000 THEN 'Silver' ELSE 'Bronze' END AS customer_segment, DENSE_RANK() OVER (ORDER BY SUM(o.total_amount) DESC) AS spending_rank, MAX(o.order_date) AS last_order_date, EXTRACT(DAY FROM AGE(CURRENT_DATE, MAX(o.order_date))) AS days_since_last_order FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email HAVING COUNT(o.order_id) > 0 ORDER BY total_spent DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.43120908737182617,0.0,0.0,0.0,89.84765625,91.51953125,1.671875,10000,1,0,0,0,0,0,0,1,0,1,2,1,0,1,6,0,
customer_spending,btree,"SELECT u.user_id, u.email, COUNT(o.order_id) as order_count, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email ORDER BY total_spent DESC NULLS LAST;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.21859002113342285,0.0,0.0,0.0,89.87890625,90.24609375,0.3671875,10000,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
customer_spending_hash,hash,"SELECT u.user_id, u.email, COUNT(o.order_id) as order_count, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email ORDER BY total_spent DESC NULLS LAST;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.17675447463989258,0.0,0.0,0.0,90.24609375,90.24609375,0.0,10000,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
customer_spending_bitmap,bitmap,"SELECT u.user_id, u.email, COUNT(o.order_id) as order_count, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email ORDER BY total_spent DESC NULLS LAST;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.18543004989624023,0.0,0.0,0.0,90.24609375,90.24609375,0.0,10000,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
customer_spending_gist,gist,"SELECT u.user_id, u.email, COUNT(o.order_id) as order_count, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email ORDER BY total_spent DESC NULLS LAST;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.1752772331237793,0.0,0.0,0.0,90.24609375,90.24609375,0.0,10000,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
customer_spending_reverse,reverse,"SELECT u.user_id, u.email, COUNT(o.order_id) as order_count, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.email ORDER BY total_spent DESC NULLS LAST;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.1928250789642334,0.0,0.0,0.0,90.24609375,90.24609375,0.0,10000,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
multi_column_category_price,btree,"SELECT p.product_id, p.name, p.price, c.name as category_name FROM Products p JOIN Categories c ON p.category_id = c.category_id WHERE p.category_id = 3 AND p.price BETWEEN 20 AND 100 ORDER BY p.price;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.002124786376953125,0.0,0.0,0.0,90.24609375,90.24609375,0.0,6,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
multi_column_category_price_hash,hash,"SELECT p.product_id, p.name, p.price, c.name as category_name FROM Products p JOIN Categories c ON p.category_id = c.category_id WHERE p.category_id = 3 AND p.price BETWEEN 20 AND 100 ORDER BY p.price;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.005888223648071289,0.0,0.0,0.0,90.24609375,90.25,0.00390625,6,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
multi_column_category_price_bitmap,bitmap,"SELECT p.product_id, p.name, p.price, c.name as category_name FROM Products p JOIN Categories c ON p.category_id = c.category_id WHERE p.category_id = 3 AND p.price BETWEEN 20 AND 100 ORDER BY p.price;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.002399921417236328,0.0,0.0,0.0,90.25,90.25,0.0,6,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
multi_column_category_price_gist,gist,"SELECT p.product_id, p.name, p.price, c.name as category_name FROM Products p JOIN Categories c ON p.category_id = c.category_id WHERE p.category_id = 3 AND p.price BETWEEN 20 AND 100 ORDER BY p.price;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.002375364303588867,0.0,0.0,0.0,90.25,90.25,0.0,6,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
multi_column_category_price_reverse,reverse,"SELECT p.product_id, p.name, p.price, c.name as category_name FROM Products p JOIN Categories c ON p.category_id = c.category_id WHERE p.category_id = 3 AND p.price BETWEEN 20 AND 100 ORDER BY p.price;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0028564929962158203,0.0,0.0,0.0,90.25390625,90.25390625,0.0,6,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
order_history,btree,"SELECT o.order_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) as items_count FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, o.total_amount, u.email ORDER BY o.order_date DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.14649343490600586,0.0,0.0,0.0,90.25390625,97.87109375,7.6171875,34379,1,0,0,0,0,0,0,2,1,1,1,0,0,1,2,0,
order_history_hash,hash,"SELECT o.order_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) as items_count FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, o.total_amount, u.email ORDER BY o.order_date DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.16516971588134766,0.0,0.0,0.0,91.44140625,97.44921875,6.0078125,34379,1,0,0,0,0,0,0,2,1,1,1,0,0,1,2,0,
order_history_bitmap,bitmap,"SELECT o.order_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) as items_count FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, o.total_amount, u.email ORDER BY o.order_date DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.16109275817871094,0.0,0.0,0.0,92.44921875,98.203125,5.75390625,34379,1,0,0,0,0,0,0,2,1,1,1,0,0,1,2,0,
order_history_gist,gist,"SELECT o.order_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) as items_count FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, o.total_amount, u.email ORDER BY o.order_date DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.15631699562072754,0.0,0.0,0.0,91.8359375,97.453125,5.6171875,34379,1,0,0,0,0,0,0,2,1,1,1,0,0,1,2,0,
order_history_reverse,reverse,"SELECT o.order_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) as items_count FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, o.total_amount, u.email ORDER BY o.order_date DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.16382312774658203,0.0,0.0,0.0,91.44921875,97.8203125,6.37109375,34379,1,0,0,0,0,0,0,2,1,1,1,0,0,1,2,0,
prefix_email_match,btree,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'john%';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.002889871597290039,0.0,0.0,0.0,92.453125,92.453125,0.0,123,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
prefix_email_match_hash,hash,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'john%';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0061187744140625,0.0,0.0,0.0,92.453125,92.453125,0.0,123,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
prefix_email_match_bitmap,bitmap,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'john%';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.002816915512084961,0.0,0.0,0.0,92.453125,92.453125,0.0,123,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
prefix_email_match_gist,gist,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'john%';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0025734901428222656,0.0,0.0,0.0,92.453125,92.453125,0.0,123,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
prefix_email_match_reverse,reverse,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'john%';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0076923370361328125,0.0,0.0,0.0,92.453125,92.453125,0.0,123,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
price_range_products,btree,"SELECT p.name, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price BETWEEN 100 AND 500 ORDER BY p.price;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0033218860626220703,0.0,0.0,0.0,92.453125,92.51953125,0.06640625,785,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
price_range_products_hash,hash,"SELECT p.name, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price BETWEEN 100 AND 500 ORDER BY p.price;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.003062009811401367,0.0,0.0,0.0,92.5234375,92.5234375,0.0,785,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
price_range_products_bitmap,bitmap,"SELECT p.name, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price BETWEEN 100 AND 500 ORDER BY p.price;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.003450155258178711,0.0,0.0,0.0,92.5234375,92.5234375,0.0,785,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
price_range_products_gist,gist,"SELECT p.name, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price BETWEEN 100 AND 500 ORDER BY p.price;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0033752918243408203,0.0,0.0,0.0,92.5234375,92.5234375,0.0,785,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
price_range_products_reverse,reverse,"SELECT p.name, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price BETWEEN 100 AND 500 ORDER BY p.price;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.003355264663696289,0.0,0.0,0.0,92.5234375,92.5234375,0.0,785,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,
product_performance_pivot,btree,"SELECT p.product_id, p.name, c.name AS category_name, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 1 THEN oi.quantity ELSE 0 END) AS Jan_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 2 THEN oi.quantity ELSE 0 END) AS Feb_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 3 THEN oi.quantity ELSE 0 END) AS Mar_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 4 THEN oi.quantity ELSE 0 END) AS Apr_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 5 THEN oi.quantity ELSE 0 END) AS May_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 6 THEN oi.quantity ELSE 0 END) AS Jun_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 7 THEN oi.quantity ELSE 0 END) AS Jul_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 8 THEN oi.quantity ELSE 0 END) AS Aug_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 9 THEN oi.quantity ELSE 0 END) AS Sep_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 10 THEN oi.quantity ELSE 0 END) AS Oct_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 11 THEN oi.quantity ELSE 0 END) AS Nov_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 12 THEN oi.quantity ELSE 0 END) AS Dec_Sales, SUM(oi.quantity) AS Total_Sales, SUM(oi.quantity * oi.price) AS Total_Revenue FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id AND EXTRACT(YEAR FROM o.order_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY p.product_id, p.name, c.name ORDER BY Total_Revenue DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),2.1937649250030518,0.0,0.0,0.0,92.46875,93.171875,0.703125,2000,1,0,0,0,0,0,0,3,0,1,1,0,0,0,3,0,
product_performance_pivot_hash,hash,"SELECT p.product_id, p.name, c.name AS category_name, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 1 THEN oi.quantity ELSE 0 END) AS Jan_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 2 THEN oi.quantity ELSE 0 END) AS Feb_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 3 THEN oi.quantity ELSE 0 END) AS Mar_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 4 THEN oi.quantity ELSE 0 END) AS Apr_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 5 THEN oi.quantity ELSE 0 END) AS May_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 6 THEN oi.quantity ELSE 0 END) AS Jun_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 7 THEN oi.quantity ELSE 0 END) AS Jul_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 8 THEN oi.quantity ELSE 0 END) AS Aug_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 9 THEN oi.quantity ELSE 0 END) AS Sep_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 10 THEN oi.quantity ELSE 0 END) AS Oct_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 11 THEN oi.quantity ELSE 0 END) AS Nov_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 12 THEN oi.quantity ELSE 0 END) AS Dec_Sales, SUM(oi.quantity) AS Total_Sales, SUM(oi.quantity * oi.price) AS Total_Revenue FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id AND EXTRACT(YEAR FROM o.order_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY p.product_id, p.name, c.name ORDER BY Total_Revenue DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),2.222048759460449,0.0,0.0,0.0,93.171875,93.171875,0.0,2000,1,0,0,0,0,0,0,3,0,1,1,0,0,0,3,0,
product_performance_pivot_bitmap,bitmap,"SELECT p.product_id, p.name, c.name AS category_name, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 1 THEN oi.quantity ELSE 0 END) AS Jan_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 2 THEN oi.quantity ELSE 0 END) AS Feb_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 3 THEN oi.quantity ELSE 0 END) AS Mar_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 4 THEN oi.quantity ELSE 0 END) AS Apr_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 5 THEN oi.quantity ELSE 0 END) AS May_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 6 THEN oi.quantity ELSE 0 END) AS Jun_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 7 THEN oi.quantity ELSE 0 END) AS Jul_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 8 THEN oi.quantity ELSE 0 END) AS Aug_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 9 THEN oi.quantity ELSE 0 END) AS Sep_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 10 THEN oi.quantity ELSE 0 END) AS Oct_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 11 THEN oi.quantity ELSE 0 END) AS Nov_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 12 THEN oi.quantity ELSE 0 END) AS Dec_Sales, SUM(oi.quantity) AS Total_Sales, SUM(oi.quantity * oi.price) AS Total_Revenue FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id AND EXTRACT(YEAR FROM o.order_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY p.product_id, p.name, c.name ORDER BY Total_Revenue DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),2.1686851978302,0.0,0.0,0.0,93.171875,93.171875,0.0,2000,1,0,0,0,0,0,0,3,0,1,1,0,0,0,3,0,
product_performance_pivot_gist,gist,"SELECT p.product_id, p.name, c.name AS category_name, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 1 THEN oi.quantity ELSE 0 END) AS Jan_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 2 THEN oi.quantity ELSE 0 END) AS Feb_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 3 THEN oi.quantity ELSE 0 END) AS Mar_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 4 THEN oi.quantity ELSE 0 END) AS Apr_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 5 THEN oi.quantity ELSE 0 END) AS May_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 6 THEN oi.quantity ELSE 0 END) AS Jun_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 7 THEN oi.quantity ELSE 0 END) AS Jul_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 8 THEN oi.quantity ELSE 0 END) AS Aug_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 9 THEN oi.quantity ELSE 0 END) AS Sep_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 10 THEN oi.quantity ELSE 0 END) AS Oct_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 11 THEN oi.quantity ELSE 0 END) AS Nov_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 12 THEN oi.quantity ELSE 0 END) AS Dec_Sales, SUM(oi.quantity) AS Total_Sales, SUM(oi.quantity * oi.price) AS Total_Revenue FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id AND EXTRACT(YEAR FROM o.order_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY p.product_id, p.name, c.name ORDER BY Total_Revenue DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),2.157524585723877,0.0,0.0,0.0,93.171875,93.171875,0.0,2000,1,0,0,0,0,0,0,3,0,1,1,0,0,0,3,0,
product_performance_pivot_reverse,reverse,"SELECT p.product_id, p.name, c.name AS category_name, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 1 THEN oi.quantity ELSE 0 END) AS Jan_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 2 THEN oi.quantity ELSE 0 END) AS Feb_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 3 THEN oi.quantity ELSE 0 END) AS Mar_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 4 THEN oi.quantity ELSE 0 END) AS Apr_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 5 THEN oi.quantity ELSE 0 END) AS May_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 6 THEN oi.quantity ELSE 0 END) AS Jun_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 7 THEN oi.quantity ELSE 0 END) AS Jul_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 8 THEN oi.quantity ELSE 0 END) AS Aug_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 9 THEN oi.quantity ELSE 0 END) AS Sep_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 10 THEN oi.quantity ELSE 0 END) AS Oct_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 11 THEN oi.quantity ELSE 0 END) AS Nov_Sales, SUM(CASE WHEN EXTRACT(MONTH FROM o.order_date) = 12 THEN oi.quantity ELSE 0 END) AS Dec_Sales, SUM(oi.quantity) AS Total_Sales, SUM(oi.quantity * oi.price) AS Total_Revenue FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id AND EXTRACT(YEAR FROM o.order_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY p.product_id, p.name, c.name ORDER BY Total_Revenue DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),2.188575506210327,0.0,0.0,0.0,93.171875,93.171875,0.0,2000,1,0,0,0,0,0,0,3,0,1,1,0,0,0,3,0,
product_price_changes,btree,"SELECT p1.product_id, p1.name, p1.price as current_price, COUNT(DISTINCT o.order_id) as total_orders, MIN(oi.price) as min_sold_price, MAX(oi.price) as max_sold_price FROM products p1 LEFT JOIN orderitems oi ON p1.product_id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.order_id GROUP BY p1.product_id, p1.name, p1.price HAVING p1.price > AVG(oi.price) ORDER BY p1.price DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),1.627718448638916,0.0,0.0,0.0,93.17578125,93.17578125,0.0,0,1,0,0,0,0,0,0,2,0,1,1,1,0,0,6,0,
product_price_changes_hash,hash,"SELECT p1.product_id, p1.name, p1.price as current_price, COUNT(DISTINCT o.order_id) as total_orders, MIN(oi.price) as min_sold_price, MAX(oi.price) as max_sold_price FROM products p1 LEFT JOIN orderitems oi ON p1.product_id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.order_id GROUP BY p1.product_id, p1.name, p1.price HAVING p1.price > AVG(oi.price) ORDER BY p1.price DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),1.6820735931396484,0.0,0.0,0.0,93.17578125,93.17578125,0.0,0,1,0,0,0,0,0,0,2,0,1,1,1,0,0,6,0,
product_price_changes_bitmap,bitmap,"SELECT p1.product_id, p1.name, p1.price as current_price, COUNT(DISTINCT o.order_id) as total_orders, MIN(oi.price) as min_sold_price, MAX(oi.price) as max_sold_price FROM products p1 LEFT JOIN orderitems oi ON p1.product_id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.order_id GROUP BY p1.product_id, p1.name, p1.price HAVING p1.price > AVG(oi.price) ORDER BY p1.price DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),1.6349260807037354,0.0,0.0,0.0,93.17578125,93.17578125,0.0,0,1,0,0,0,0,0,0,2,0,1,1,1,0,0,6,0,
product_price_changes_gist,gist,"SELECT p1.product_id, p1.name, p1.price as current_price, COUNT(DISTINCT o.order_id) as total_orders, MIN(oi.price) as min_sold_price, MAX(oi.price) as max_sold_price FROM products p1 LEFT JOIN orderitems oi ON p1.product_id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.order_id GROUP BY p1.product_id, p1.name, p1.price HAVING p1.price > AVG(oi.price) ORDER BY p1.price DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),1.6438567638397217,0.0,0.0,0.0,93.17578125,93.17578125,0.0,0,1,0,0,0,0,0,0,2,0,1,1,1,0,0,6,0,
product_price_changes_reverse,reverse,"SELECT p1.product_id, p1.name, p1.price as current_price, COUNT(DISTINCT o.order_id) as total_orders, MIN(oi.price) as min_sold_price, MAX(oi.price) as max_sold_price FROM products p1 LEFT JOIN orderitems oi ON p1.product_id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.order_id GROUP BY p1.product_id, p1.name, p1.price HAVING p1.price > AVG(oi.price) ORDER BY p1.price DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),1.631619930267334,0.0,0.0,0.0,93.17578125,93.17578125,0.0,0,1,0,0,0,0,0,0,2,0,1,1,1,0,0,6,0,
product_sales_ranking,btree,"SELECT p.product_id, p.name, SUM(oi.quantity) as total_sold, SUM(oi.quantity * oi.price) as total_revenue, RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) as revenue_rank FROM products p JOIN orderitems oi ON p.product_id = oi.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.2574734687805176,0.0,0.0,0.0,93.17578125,93.17578125,0.0,2000,1,0,0,0,0,0,0,1,0,1,2,0,0,0,1,0,
product_sales_ranking_hash,hash,"SELECT p.product_id, p.name, SUM(oi.quantity) as total_sold, SUM(oi.quantity * oi.price) as total_revenue, RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) as revenue_rank FROM products p JOIN orderitems oi ON p.product_id = oi.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.2204573154449463,0.0,0.0,0.0,93.1796875,93.1796875,0.0,2000,1,0,0,0,0,0,0,1,0,1,2,0,0,0,1,0,
product_sales_ranking_bitmap,bitmap,"SELECT p.product_id, p.name, SUM(oi.quantity) as total_sold, SUM(oi.quantity * oi.price) as total_revenue, RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) as revenue_rank FROM products p JOIN orderitems oi ON p.product_id = oi.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.24026966094970703,0.0,0.0,0.0,93.1796875,93.1796875,0.0,2000,1,0,0,0,0,0,0,1,0,1,2,0,0,0,1,0,
product_sales_ranking_gist,gist,"SELECT p.product_id, p.name, SUM(oi.quantity) as total_sold, SUM(oi.quantity * oi.price) as total_revenue, RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) as revenue_rank FROM products p JOIN orderitems oi ON p.product_id = oi.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.22434210777282715,0.0,0.0,0.0,93.1796875,93.1796875,0.0,2000,1,0,0,0,0,0,0,1,0,1,2,0,0,0,1,0,
product_sales_ranking_reverse,reverse,"SELECT p.product_id, p.name, SUM(oi.quantity) as total_sold, SUM(oi.quantity * oi.price) as total_revenue, RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) as revenue_rank FROM products p JOIN orderitems oi ON p.product_id = oi.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.2397019863128662,0.0,0.0,0.0,93.1796875,93.1796875,0.0,2000,1,0,0,0,0,0,0,1,0,1,2,0,0,0,1,0,
range_product_price,btree,"SELECT product_id, name, price FROM Products WHERE price BETWEEN 50 AND 150 ORDER BY price;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.007054567337036133,0.0,0.0,0.0,93.1796875,93.1796875,0.0,208,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
range_product_price_hash,hash,"SELECT product_id, name, price FROM Products WHERE price BETWEEN 50 AND 150 ORDER BY price;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0026328563690185547,0.0,0.0,0.0,93.1796875,93.1796875,0.0,208,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
range_product_price_bitmap,bitmap,"SELECT product_id, name, price FROM Products WHERE price BETWEEN 50 AND 150 ORDER BY price;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0043926239013671875,0.0,0.0,0.0,93.1796875,93.1796875,0.0,208,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
range_product_price_gist,gist,"SELECT product_id, name, price FROM Products WHERE price BETWEEN 50 AND 150 ORDER BY price;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0057315826416015625,0.0,0.0,0.0,93.1796875,93.1796875,0.0,208,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
range_product_price_reverse,reverse,"SELECT product_id, name, price FROM Products WHERE price BETWEEN 50 AND 150 ORDER BY price;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0056111812591552734,0.0,0.0,0.0,93.1796875,93.1796875,0.0,208,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
range_sort_order_date,btree,"SELECT order_id, user_id, order_date, total_amount FROM Orders WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31' ORDER BY order_date DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.021646499633789062,0.0,0.0,0.0,93.1796875,93.51171875,0.33203125,8775,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
range_sort_order_date_hash,hash,"SELECT order_id, user_id, order_date, total_amount FROM Orders WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31' ORDER BY order_date DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.04335927963256836,0.0,0.0,0.0,93.51171875,93.515625,0.00390625,8775,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
range_sort_order_date_bitmap,bitmap,"SELECT order_id, user_id, order_date, total_amount FROM Orders WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31' ORDER BY order_date DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.04537606239318848,0.0,0.0,0.0,93.515625,93.515625,0.0,8775,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
range_sort_order_date_gist,gist,"SELECT order_id, user_id, order_date, total_amount FROM Orders WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31' ORDER BY order_date DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.02274155616760254,0.0,0.0,0.0,93.515625,93.515625,0.0,8775,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
range_sort_order_date_reverse,reverse,"SELECT order_id, user_id, order_date, total_amount FROM Orders WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31' ORDER BY order_date DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.04104351997375488,0.0,0.0,0.0,93.515625,93.515625,0.0,8775,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,
sales_dashboard,btree,"WITH DailySales AS ( SELECT DATE(o.order_date) AS sale_date, EXTRACT(YEAR FROM o.order_date) AS year, EXTRACT(MONTH FROM o.order_date) AS month, EXTRACT(DOW FROM o.order_date) + 1 AS day_of_week,  -- Adjusted for PostgreSQL EXTRACT(DOY FROM o.order_date) AS day_of_year, EXTRACT(QUARTER FROM o.order_date) AS quarter, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count, SUM(o.total_amount) AS revenue, AVG(o.total_amount) AS avg_order_value, SUM(oi.quantity) AS units_sold FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '3 years' GROUP BY DATE(o.order_date),  -- Include the same expression used in SELECT EXTRACT(YEAR FROM o.order_date),  -- Added to GROUP BY EXTRACT(MONTH FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOW FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOY FROM o.order_date),  -- Added to GROUP BY EXTRACT(QUARTER FROM o.order_date)  -- Added to GROUP BY ) SELECT ds.*, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_7day_avg_revenue, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW) AS rolling_30day_avg_revenue, LAG(revenue, 365) OVER (ORDER BY sale_date) AS revenue_last_year, CASE WHEN LAG(revenue, 365) OVER (ORDER BY sale_date) IS NOT NULL THEN (revenue - LAG(revenue, 365) OVER (ORDER BY sale_date)) / NULLIF(LAG(revenue, 365) OVER (ORDER BY sale_date), 0) * 100 ELSE NULL END AS yoy_revenue_growth, AVG(revenue) OVER (PARTITION BY day_of_week) AS avg_revenue_by_day_of_week, AVG(revenue) OVER (PARTITION BY month) AS avg_revenue_by_month, AVG(revenue) OVER (PARTITION BY quarter) AS avg_revenue_by_quarter, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY day_of_week), 0) AS day_of_week_index, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY month), 0) AS month_index, DENSE_RANK() OVER (PARTITION BY year, month ORDER BY revenue DESC) AS day_rank_in_month, DENSE_RANK() OVER (PARTITION BY year ORDER BY revenue DESC) AS day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;
                                                                       ^
"
sales_dashboard_hash,hash,"WITH DailySales AS ( SELECT DATE(o.order_date) AS sale_date, EXTRACT(YEAR FROM o.order_date) AS year, EXTRACT(MONTH FROM o.order_date) AS month, EXTRACT(DOW FROM o.order_date) + 1 AS day_of_week,  -- Adjusted for PostgreSQL EXTRACT(DOY FROM o.order_date) AS day_of_year, EXTRACT(QUARTER FROM o.order_date) AS quarter, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count, SUM(o.total_amount) AS revenue, AVG(o.total_amount) AS avg_order_value, SUM(oi.quantity) AS units_sold FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '3 years' GROUP BY DATE(o.order_date),  -- Include the same expression used in SELECT EXTRACT(YEAR FROM o.order_date),  -- Added to GROUP BY EXTRACT(MONTH FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOW FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOY FROM o.order_date),  -- Added to GROUP BY EXTRACT(QUARTER FROM o.order_date)  -- Added to GROUP BY ) SELECT ds.*, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_7day_avg_revenue, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW) AS rolling_30day_avg_revenue, LAG(revenue, 365) OVER (ORDER BY sale_date) AS revenue_last_year, CASE WHEN LAG(revenue, 365) OVER (ORDER BY sale_date) IS NOT NULL THEN (revenue - LAG(revenue, 365) OVER (ORDER BY sale_date)) / NULLIF(LAG(revenue, 365) OVER (ORDER BY sale_date), 0) * 100 ELSE NULL END AS yoy_revenue_growth, AVG(revenue) OVER (PARTITION BY day_of_week) AS avg_revenue_by_day_of_week, AVG(revenue) OVER (PARTITION BY month) AS avg_revenue_by_month, AVG(revenue) OVER (PARTITION BY quarter) AS avg_revenue_by_quarter, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY day_of_week), 0) AS day_of_week_index, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY month), 0) AS month_index, DENSE_RANK() OVER (PARTITION BY year, month ORDER BY revenue DESC) AS day_rank_in_month, DENSE_RANK() OVER (PARTITION BY year ORDER BY revenue DESC) AS day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;
                                                                       ^
"
sales_dashboard_bitmap,bitmap,"WITH DailySales AS ( SELECT DATE(o.order_date) AS sale_date, EXTRACT(YEAR FROM o.order_date) AS year, EXTRACT(MONTH FROM o.order_date) AS month, EXTRACT(DOW FROM o.order_date) + 1 AS day_of_week,  -- Adjusted for PostgreSQL EXTRACT(DOY FROM o.order_date) AS day_of_year, EXTRACT(QUARTER FROM o.order_date) AS quarter, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count, SUM(o.total_amount) AS revenue, AVG(o.total_amount) AS avg_order_value, SUM(oi.quantity) AS units_sold FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '3 years' GROUP BY DATE(o.order_date),  -- Include the same expression used in SELECT EXTRACT(YEAR FROM o.order_date),  -- Added to GROUP BY EXTRACT(MONTH FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOW FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOY FROM o.order_date),  -- Added to GROUP BY EXTRACT(QUARTER FROM o.order_date)  -- Added to GROUP BY ) SELECT ds.*, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_7day_avg_revenue, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW) AS rolling_30day_avg_revenue, LAG(revenue, 365) OVER (ORDER BY sale_date) AS revenue_last_year, CASE WHEN LAG(revenue, 365) OVER (ORDER BY sale_date) IS NOT NULL THEN (revenue - LAG(revenue, 365) OVER (ORDER BY sale_date)) / NULLIF(LAG(revenue, 365) OVER (ORDER BY sale_date), 0) * 100 ELSE NULL END AS yoy_revenue_growth, AVG(revenue) OVER (PARTITION BY day_of_week) AS avg_revenue_by_day_of_week, AVG(revenue) OVER (PARTITION BY month) AS avg_revenue_by_month, AVG(revenue) OVER (PARTITION BY quarter) AS avg_revenue_by_quarter, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY day_of_week), 0) AS day_of_week_index, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY month), 0) AS month_index, DENSE_RANK() OVER (PARTITION BY year, month ORDER BY revenue DESC) AS day_rank_in_month, DENSE_RANK() OVER (PARTITION BY year ORDER BY revenue DESC) AS day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;
                                                                       ^
"
sales_dashboard_gist,gist,"WITH DailySales AS ( SELECT DATE(o.order_date) AS sale_date, EXTRACT(YEAR FROM o.order_date) AS year, EXTRACT(MONTH FROM o.order_date) AS month, EXTRACT(DOW FROM o.order_date) + 1 AS day_of_week,  -- Adjusted for PostgreSQL EXTRACT(DOY FROM o.order_date) AS day_of_year, EXTRACT(QUARTER FROM o.order_date) AS quarter, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count, SUM(o.total_amount) AS revenue, AVG(o.total_amount) AS avg_order_value, SUM(oi.quantity) AS units_sold FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '3 years' GROUP BY DATE(o.order_date),  -- Include the same expression used in SELECT EXTRACT(YEAR FROM o.order_date),  -- Added to GROUP BY EXTRACT(MONTH FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOW FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOY FROM o.order_date),  -- Added to GROUP BY EXTRACT(QUARTER FROM o.order_date)  -- Added to GROUP BY ) SELECT ds.*, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_7day_avg_revenue, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW) AS rolling_30day_avg_revenue, LAG(revenue, 365) OVER (ORDER BY sale_date) AS revenue_last_year, CASE WHEN LAG(revenue, 365) OVER (ORDER BY sale_date) IS NOT NULL THEN (revenue - LAG(revenue, 365) OVER (ORDER BY sale_date)) / NULLIF(LAG(revenue, 365) OVER (ORDER BY sale_date), 0) * 100 ELSE NULL END AS yoy_revenue_growth, AVG(revenue) OVER (PARTITION BY day_of_week) AS avg_revenue_by_day_of_week, AVG(revenue) OVER (PARTITION BY month) AS avg_revenue_by_month, AVG(revenue) OVER (PARTITION BY quarter) AS avg_revenue_by_quarter, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY day_of_week), 0) AS day_of_week_index, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY month), 0) AS month_index, DENSE_RANK() OVER (PARTITION BY year, month ORDER BY revenue DESC) AS day_rank_in_month, DENSE_RANK() OVER (PARTITION BY year ORDER BY revenue DESC) AS day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;
                                                                       ^
"
sales_dashboard_reverse,reverse,"WITH DailySales AS ( SELECT DATE(o.order_date) AS sale_date, EXTRACT(YEAR FROM o.order_date) AS year, EXTRACT(MONTH FROM o.order_date) AS month, EXTRACT(DOW FROM o.order_date) + 1 AS day_of_week,  -- Adjusted for PostgreSQL EXTRACT(DOY FROM o.order_date) AS day_of_year, EXTRACT(QUARTER FROM o.order_date) AS quarter, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count, SUM(o.total_amount) AS revenue, AVG(o.total_amount) AS avg_order_value, SUM(oi.quantity) AS units_sold FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '3 years' GROUP BY DATE(o.order_date),  -- Include the same expression used in SELECT EXTRACT(YEAR FROM o.order_date),  -- Added to GROUP BY EXTRACT(MONTH FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOW FROM o.order_date),  -- Added to GROUP BY EXTRACT(DOY FROM o.order_date),  -- Added to GROUP BY EXTRACT(QUARTER FROM o.order_date)  -- Added to GROUP BY ) SELECT ds.*, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_7day_avg_revenue, AVG(revenue) OVER (ORDER BY sale_date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW) AS rolling_30day_avg_revenue, LAG(revenue, 365) OVER (ORDER BY sale_date) AS revenue_last_year, CASE WHEN LAG(revenue, 365) OVER (ORDER BY sale_date) IS NOT NULL THEN (revenue - LAG(revenue, 365) OVER (ORDER BY sale_date)) / NULLIF(LAG(revenue, 365) OVER (ORDER BY sale_date), 0) * 100 ELSE NULL END AS yoy_revenue_growth, AVG(revenue) OVER (PARTITION BY day_of_week) AS avg_revenue_by_day_of_week, AVG(revenue) OVER (PARTITION BY month) AS avg_revenue_by_month, AVG(revenue) OVER (PARTITION BY quarter) AS avg_revenue_by_quarter, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY day_of_week), 0) AS day_of_week_index, revenue / NULLIF(AVG(revenue) OVER (PARTITION BY month), 0) AS month_index, DENSE_RANK() OVER (PARTITION BY year, month ORDER BY revenue DESC) AS day_rank_in_month, DENSE_RANK() OVER (PARTITION BY year ORDER BY revenue DESC) AS day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...day_rank_in_year FROM DailySales ds ORDER BY sale_date DESC;
                                                                       ^
"
time_series_analysis,btree,"WITH MonthlyRevenue AS ( SELECT TO_CHAR(o.order_date, 'YYYY-MM') AS month,  -- Changed DATE_FORMAT to TO_CHAR for PostgreSQL c.category_id, c.name AS category_name, SUM(oi.quantity * oi.price) AS monthly_revenue, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id JOIN Categories c ON p.category_id = c.category_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '24 months'  -- Adjusted for PostgreSQL GROUP BY TO_CHAR(o.order_date, 'YYYY-MM'), c.category_id, c.name  -- Changed DATE_FORMAT to TO_CHAR ) SELECT mr.month, mr.category_name, mr.monthly_revenue, mr.order_count, mr.customer_count, LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month) AS prev_month_revenue, (mr.monthly_revenue - LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS month_over_month_growth, (mr.monthly_revenue - LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS year_over_year_growth, AVG(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_3_month_avg, SUM(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_revenue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...ue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;
                                                                       ^
"
time_series_analysis_hash,hash,"WITH MonthlyRevenue AS ( SELECT TO_CHAR(o.order_date, 'YYYY-MM') AS month,  -- Changed DATE_FORMAT to TO_CHAR for PostgreSQL c.category_id, c.name AS category_name, SUM(oi.quantity * oi.price) AS monthly_revenue, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id JOIN Categories c ON p.category_id = c.category_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '24 months'  -- Adjusted for PostgreSQL GROUP BY TO_CHAR(o.order_date, 'YYYY-MM'), c.category_id, c.name  -- Changed DATE_FORMAT to TO_CHAR ) SELECT mr.month, mr.category_name, mr.monthly_revenue, mr.order_count, mr.customer_count, LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month) AS prev_month_revenue, (mr.monthly_revenue - LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS month_over_month_growth, (mr.monthly_revenue - LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS year_over_year_growth, AVG(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_3_month_avg, SUM(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_revenue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...ue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;
                                                                       ^
"
time_series_analysis_bitmap,bitmap,"WITH MonthlyRevenue AS ( SELECT TO_CHAR(o.order_date, 'YYYY-MM') AS month,  -- Changed DATE_FORMAT to TO_CHAR for PostgreSQL c.category_id, c.name AS category_name, SUM(oi.quantity * oi.price) AS monthly_revenue, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id JOIN Categories c ON p.category_id = c.category_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '24 months'  -- Adjusted for PostgreSQL GROUP BY TO_CHAR(o.order_date, 'YYYY-MM'), c.category_id, c.name  -- Changed DATE_FORMAT to TO_CHAR ) SELECT mr.month, mr.category_name, mr.monthly_revenue, mr.order_count, mr.customer_count, LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month) AS prev_month_revenue, (mr.monthly_revenue - LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS month_over_month_growth, (mr.monthly_revenue - LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS year_over_year_growth, AVG(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_3_month_avg, SUM(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_revenue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...ue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;
                                                                       ^
"
time_series_analysis_gist,gist,"WITH MonthlyRevenue AS ( SELECT TO_CHAR(o.order_date, 'YYYY-MM') AS month,  -- Changed DATE_FORMAT to TO_CHAR for PostgreSQL c.category_id, c.name AS category_name, SUM(oi.quantity * oi.price) AS monthly_revenue, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id JOIN Categories c ON p.category_id = c.category_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '24 months'  -- Adjusted for PostgreSQL GROUP BY TO_CHAR(o.order_date, 'YYYY-MM'), c.category_id, c.name  -- Changed DATE_FORMAT to TO_CHAR ) SELECT mr.month, mr.category_name, mr.monthly_revenue, mr.order_count, mr.customer_count, LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month) AS prev_month_revenue, (mr.monthly_revenue - LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS month_over_month_growth, (mr.monthly_revenue - LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS year_over_year_growth, AVG(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_3_month_avg, SUM(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_revenue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...ue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;
                                                                       ^
"
time_series_analysis_reverse,reverse,"WITH MonthlyRevenue AS ( SELECT TO_CHAR(o.order_date, 'YYYY-MM') AS month,  -- Changed DATE_FORMAT to TO_CHAR for PostgreSQL c.category_id, c.name AS category_name, SUM(oi.quantity * oi.price) AS monthly_revenue, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.user_id) AS customer_count FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id JOIN Categories c ON p.category_id = c.category_id WHERE o.status != 'Cancelled' AND o.order_date >= CURRENT_DATE - INTERVAL '24 months'  -- Adjusted for PostgreSQL GROUP BY TO_CHAR(o.order_date, 'YYYY-MM'), c.category_id, c.name  -- Changed DATE_FORMAT to TO_CHAR ) SELECT mr.month, mr.category_name, mr.monthly_revenue, mr.order_count, mr.customer_count, LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month) AS prev_month_revenue, (mr.monthly_revenue - LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 1) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS month_over_month_growth, (mr.monthly_revenue - LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month)) / NULLIF(LAG(mr.monthly_revenue, 12) OVER (PARTITION BY mr.category_id ORDER BY mr.month), 0) * 100 AS year_over_year_growth, AVG(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_3_month_avg, SUM(mr.monthly_revenue) OVER (PARTITION BY mr.category_id ORDER BY mr.month ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_revenue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...ue FROM MonthlyRevenue mr ORDER BY mr.category_id, mr.month;
                                                                       ^
"
category_lookup,hash,SELECT * FROM categories WHERE category_id = 5;,Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0023903846740722656,0.0,0.0,0.0,93.5390625,93.5390625,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
category_lookup_btree,btree,SELECT * FROM categories WHERE category_id = 5;,B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.002118825912475586,0.0,0.0,0.0,93.5390625,93.5390625,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
category_lookup_bitmap,bitmap,SELECT * FROM categories WHERE category_id = 5;,Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0014185905456542969,0.0,0.0,0.0,93.5390625,93.5390625,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
category_lookup_gist,gist,SELECT * FROM categories WHERE category_id = 5;,GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0019724369049072266,0.0,0.0,0.0,93.5390625,93.5390625,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
category_lookup_reverse,reverse,SELECT * FROM categories WHERE category_id = 5;,Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0020868778228759766,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
category_products,hash,"SELECT p.product_id, p.name, p.price, p.stock_quantity, p.created_at FROM Products p WHERE p.category_id = 5 ORDER BY p.price ASC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.005647897720336914,0.0,0.0,0.0,93.54296875,93.54296875,0.0,101,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,
category_products_btree,btree,"SELECT p.product_id, p.name, p.price, p.stock_quantity, p.created_at FROM Products p WHERE p.category_id = 5 ORDER BY p.price ASC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0021924972534179688,0.0,0.0,0.0,93.54296875,93.54296875,0.0,101,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,
category_products_bitmap,bitmap,"SELECT p.product_id, p.name, p.price, p.stock_quantity, p.created_at FROM Products p WHERE p.category_id = 5 ORDER BY p.price ASC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.002953052520751953,0.0,0.0,0.0,93.54296875,93.54296875,0.0,101,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,
category_products_gist,gist,"SELECT p.product_id, p.name, p.price, p.stock_quantity, p.created_at FROM Products p WHERE p.category_id = 5 ORDER BY p.price ASC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.005344867706298828,0.0,0.0,0.0,93.54296875,93.54296875,0.0,101,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,
category_products_reverse,reverse,"SELECT p.product_id, p.name, p.price, p.stock_quantity, p.created_at FROM Products p WHERE p.category_id = 5 ORDER BY p.price ASC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0025949478149414062,0.0,0.0,0.0,93.54296875,93.54296875,0.0,101,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,
daily_order_lookup,hash,"SELECT o.order_id, o.order_date, u.email, SUM(oi.quantity) as total_items, STRING_AGG(p.name, ', ') as products_ordered FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 5000 GROUP BY o.order_id, o.order_date, u.email;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.04005742073059082,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,3,1,1,0,0,0,0,4,0,
daily_order_lookup_btree,btree,"SELECT o.order_id, o.order_date, u.email, SUM(oi.quantity) as total_items, STRING_AGG(p.name, ', ') as products_ordered FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 5000 GROUP BY o.order_id, o.order_date, u.email;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.005903005599975586,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,3,1,1,0,0,0,0,4,0,
daily_order_lookup_bitmap,bitmap,"SELECT o.order_id, o.order_date, u.email, SUM(oi.quantity) as total_items, STRING_AGG(p.name, ', ') as products_ordered FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 5000 GROUP BY o.order_id, o.order_date, u.email;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.03809094429016113,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,3,1,1,0,0,0,0,4,0,
daily_order_lookup_gist,gist,"SELECT o.order_id, o.order_date, u.email, SUM(oi.quantity) as total_items, STRING_AGG(p.name, ', ') as products_ordered FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 5000 GROUP BY o.order_id, o.order_date, u.email;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.04258608818054199,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,3,1,1,0,0,0,0,4,0,
daily_order_lookup_reverse,reverse,"SELECT o.order_id, o.order_date, u.email, SUM(oi.quantity) as total_items, STRING_AGG(p.name, ', ') as products_ordered FROM orders o JOIN users u ON o.user_id = u.user_id JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 5000 GROUP BY o.order_id, o.order_date, u.email;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.03797650337219238,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,3,1,1,0,0,0,0,4,0,
exact_email_match,hash,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'newtontodd@example.net';  -- Changed to single quotes and removed extra wildcard",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.004937171936035156,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,
exact_email_match_btree,btree,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'newtontodd@example.net';  -- Changed to single quotes and removed extra wildcard",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.006392478942871094,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,
exact_email_match_bitmap,bitmap,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'newtontodd@example.net';  -- Changed to single quotes and removed extra wildcard",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0024118423461914062,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,
exact_email_match_gist,gist,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'newtontodd@example.net';  -- Changed to single quotes and removed extra wildcard",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0031566619873046875,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,
exact_email_match_reverse,reverse,"SELECT user_id, first_name, last_name, email FROM Users WHERE email LIKE 'newtontodd@example.net';  -- Changed to single quotes and removed extra wildcard",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.007650852203369141,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,
exact_order_lookup,hash,"SELECT o.order_id, o.user_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) AS item_count, SUM(oi.quantity) AS total_quantity FROM Orders o JOIN Users u ON o.user_id = u.user_id JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.order_id = 12345 GROUP BY o.order_id, o.user_id, o.order_date, o.total_amount, u.email;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.04360532760620117,0.0,0.0,0.0,93.54296875,93.54296875,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,2,0,
exact_order_lookup_btree,btree,"SELECT o.order_id, o.user_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) AS item_count, SUM(oi.quantity) AS total_quantity FROM Orders o JOIN Users u ON o.user_id = u.user_id JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.order_id = 12345 GROUP BY o.order_id, o.user_id, o.order_date, o.total_amount, u.email;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0016329288482666016,0.0,0.0,0.0,93.53125,93.53125,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,2,0,
exact_order_lookup_bitmap,bitmap,"SELECT o.order_id, o.user_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) AS item_count, SUM(oi.quantity) AS total_quantity FROM Orders o JOIN Users u ON o.user_id = u.user_id JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.order_id = 12345 GROUP BY o.order_id, o.user_id, o.order_date, o.total_amount, u.email;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.037976980209350586,0.0,0.0,0.0,93.53125,93.53125,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,2,0,
exact_order_lookup_gist,gist,"SELECT o.order_id, o.user_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) AS item_count, SUM(oi.quantity) AS total_quantity FROM Orders o JOIN Users u ON o.user_id = u.user_id JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.order_id = 12345 GROUP BY o.order_id, o.user_id, o.order_date, o.total_amount, u.email;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.041454315185546875,0.0,0.0,0.0,93.53125,93.53125,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,2,0,
exact_order_lookup_reverse,reverse,"SELECT o.order_id, o.user_id, o.order_date, o.total_amount, u.email, COUNT(oi.order_item_id) AS item_count, SUM(oi.quantity) AS total_quantity FROM Orders o JOIN Users u ON o.user_id = u.user_id JOIN OrderItems oi ON o.order_id = oi.order_id WHERE o.order_id = 12345 GROUP BY o.order_id, o.user_id, o.order_date, o.total_amount, u.email;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.05118918418884277,0.0,0.0,0.0,93.53515625,93.53515625,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,2,0,
exact_order_status,hash,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Shipped';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.1613178253173828,0.0,0.0,0.0,93.53515625,123.03125,29.49609375,118505,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
exact_order_status_btree,btree,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Shipped';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.15571355819702148,0.0,0.0,0.0,94.234375,122.77734375,28.54296875,118505,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
exact_order_status_bitmap,bitmap,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Shipped';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.14874005317687988,0.0,0.0,0.0,95.22265625,122.94140625,27.71875,118505,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
exact_order_status_gist,gist,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Shipped';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.1569368839263916,0.0,0.0,0.0,96.15625,123.203125,27.046875,118505,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
exact_order_status_reverse,reverse,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Shipped';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.157942533493042,0.0,0.0,0.0,98.12109375,122.796875,24.67578125,118505,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
exact_product_match,hash,"SELECT product_id, name, price FROM Products WHERE product_id = 5423;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0018985271453857422,0.0,0.0,0.0,98.21875,98.21875,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
exact_product_match_btree,btree,"SELECT product_id, name, price FROM Products WHERE product_id = 5423;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0017905235290527344,0.0,0.0,0.0,98.21875,98.21875,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
exact_product_match_bitmap,bitmap,"SELECT product_id, name, price FROM Products WHERE product_id = 5423;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.002335071563720703,0.0,0.0,0.0,98.21875,98.21875,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
exact_product_match_gist,gist,"SELECT product_id, name, price FROM Products WHERE product_id = 5423;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0019044876098632812,0.0,0.0,0.0,98.21875,98.21875,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
exact_product_match_reverse,reverse,"SELECT product_id, name, price FROM Products WHERE product_id = 5423;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0018455982208251953,0.0,0.0,0.0,98.21875,98.21875,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
join_exact_match,hash,"SELECT o.order_id, o.order_date, p.name as product_name FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.05055427551269531,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
join_exact_match_btree,btree,"SELECT o.order_id, o.order_date, p.name as product_name FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.002257823944091797,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
join_exact_match_bitmap,bitmap,"SELECT o.order_id, o.order_date, p.name as product_name FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.04991292953491211,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
join_exact_match_gist,gist,"SELECT o.order_id, o.order_date, p.name as product_name FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.037421464920043945,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
join_exact_match_reverse,reverse,"SELECT o.order_id, o.order_date, p.name as product_name FROM Orders o JOIN OrderItems oi ON o.order_id = oi.order_id JOIN Products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.03704524040222168,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
order_details,hash,"SELECT o.order_id, o.order_date, oi.product_id, p.name as product_name, oi.quantity, oi.price FROM orders o JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.048651933670043945,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
order_details_btree,btree,"SELECT o.order_id, o.order_date, oi.product_id, p.name as product_name, oi.quantity, oi.price FROM orders o JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0024192333221435547,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
order_details_bitmap,bitmap,"SELECT o.order_id, o.order_date, oi.product_id, p.name as product_name, oi.quantity, oi.price FROM orders o JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.03915858268737793,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
order_details_gist,gist,"SELECT o.order_id, o.order_date, oi.product_id, p.name as product_name, oi.quantity, oi.price FROM orders o JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.04091215133666992,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
order_details_reverse,reverse,"SELECT o.order_id, o.order_date, oi.product_id, p.name as product_name, oi.quantity, oi.price FROM orders o JOIN orderitems oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_id = 12345;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.04106473922729492,0.0,0.0,0.0,98.21875,98.21875,0.0,5,1,0,0,0,0,0,0,2,1,0,0,0,0,0,2,0,
product_details,hash,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name AS category_name, COUNT(DISTINCT oi.order_id) AS times_ordered, SUM(oi.quantity) AS total_quantity_sold FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id WHERE p.product_id = 1502 GROUP BY p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.045332908630371094,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,3,0,
product_details_btree,btree,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name AS category_name, COUNT(DISTINCT oi.order_id) AS times_ordered, SUM(oi.quantity) AS total_quantity_sold FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id WHERE p.product_id = 1502 GROUP BY p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0038819313049316406,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,3,0,
product_details_bitmap,bitmap,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name AS category_name, COUNT(DISTINCT oi.order_id) AS times_ordered, SUM(oi.quantity) AS total_quantity_sold FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id WHERE p.product_id = 1502 GROUP BY p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.042009830474853516,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,3,0,
product_details_gist,gist,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name AS category_name, COUNT(DISTINCT oi.order_id) AS times_ordered, SUM(oi.quantity) AS total_quantity_sold FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id WHERE p.product_id = 1502 GROUP BY p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.04338335990905762,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,3,0,
product_details_reverse,reverse,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name AS category_name, COUNT(DISTINCT oi.order_id) AS times_ordered, SUM(oi.quantity) AS total_quantity_sold FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id WHERE p.product_id = 1502 GROUP BY p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.03849148750305176,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,2,1,1,0,0,0,0,3,0,
product_info,hash,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name as category_name FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.product_id = 100;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0022728443145751953,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
product_info_btree,btree,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name as category_name FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.product_id = 100;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0028052330017089844,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
product_info_bitmap,bitmap,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name as category_name FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.product_id = 100;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.002220630645751953,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
product_info_gist,gist,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name as category_name FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.product_id = 100;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.001981973648071289,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
product_info_reverse,reverse,"SELECT p.product_id, p.name, p.description, p.price, p.stock_quantity, c.name as category_name FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.product_id = 100;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.001996278762817383,0.0,0.0,0.0,98.21875,98.21875,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
specific_product_orders,hash,"SELECT p.product_id, p.name, o.order_date, u.email as customer_email, oi.quantity, oi.price as sold_price FROM products p JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id JOIN users u ON o.user_id = u.user_id WHERE p.product_id = 123;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.043840646743774414,0.0,0.0,0.0,98.21875,98.2890625,0.0703125,735,1,0,0,0,0,0,0,3,1,0,0,0,0,0,3,0,
specific_product_orders_btree,btree,"SELECT p.product_id, p.name, o.order_date, u.email as customer_email, oi.quantity, oi.price as sold_price FROM products p JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id JOIN users u ON o.user_id = u.user_id WHERE p.product_id = 123;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.011255979537963867,0.0,0.0,0.0,98.2890625,98.2890625,0.0,735,1,0,0,0,0,0,0,3,1,0,0,0,0,0,3,0,
specific_product_orders_bitmap,bitmap,"SELECT p.product_id, p.name, o.order_date, u.email as customer_email, oi.quantity, oi.price as sold_price FROM products p JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id JOIN users u ON o.user_id = u.user_id WHERE p.product_id = 123;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.04237961769104004,0.0,0.0,0.0,98.2890625,98.2890625,0.0,735,1,0,0,0,0,0,0,3,1,0,0,0,0,0,3,0,
specific_product_orders_gist,gist,"SELECT p.product_id, p.name, o.order_date, u.email as customer_email, oi.quantity, oi.price as sold_price FROM products p JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id JOIN users u ON o.user_id = u.user_id WHERE p.product_id = 123;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.04584789276123047,0.0,0.0,0.0,98.2890625,98.2890625,0.0,735,1,0,0,0,0,0,0,3,1,0,0,0,0,0,3,0,
specific_product_orders_reverse,reverse,"SELECT p.product_id, p.name, o.order_date, u.email as customer_email, oi.quantity, oi.price as sold_price FROM products p JOIN orderitems oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id JOIN users u ON o.user_id = u.user_id WHERE p.product_id = 123;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.05267500877380371,0.0,0.0,0.0,98.2890625,98.2890625,0.0,735,1,0,0,0,0,0,0,3,1,0,0,0,0,0,3,0,
user_last_order,hash,"SELECT u.user_id, u.email, o.order_id, o.order_date, o.total_amount FROM users u JOIN orders o ON u.user_id = o.user_id WHERE u.user_id = 789 ORDER BY o.order_date DESC LIMIT 1;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.030869722366333008,0.0,0.0,0.0,98.2890625,98.2890625,0.0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,
user_last_order_btree,btree,"SELECT u.user_id, u.email, o.order_id, o.order_date, o.total_amount FROM users u JOIN orders o ON u.user_id = o.user_id WHERE u.user_id = 789 ORDER BY o.order_date DESC LIMIT 1;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.003980159759521484,0.0,0.0,0.0,98.2890625,98.2890625,0.0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,
user_last_order_bitmap,bitmap,"SELECT u.user_id, u.email, o.order_id, o.order_date, o.total_amount FROM users u JOIN orders o ON u.user_id = o.user_id WHERE u.user_id = 789 ORDER BY o.order_date DESC LIMIT 1;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.025200366973876953,0.0,0.0,0.0,98.2890625,98.2890625,0.0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,
user_last_order_gist,gist,"SELECT u.user_id, u.email, o.order_id, o.order_date, o.total_amount FROM users u JOIN orders o ON u.user_id = o.user_id WHERE u.user_id = 789 ORDER BY o.order_date DESC LIMIT 1;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.026184797286987305,0.0,0.0,0.0,98.2890625,98.2890625,0.0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,
user_last_order_reverse,reverse,"SELECT u.user_id, u.email, o.order_id, o.order_date, o.total_amount FROM users u JOIN orders o ON u.user_id = o.user_id WHERE u.user_id = 789 ORDER BY o.order_date DESC LIMIT 1;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.029126644134521484,0.0,0.0,0.0,98.2890625,98.2890625,0.0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,
user_lookup,hash,"SELECT u.user_id, u.email, u.first_name, u.last_name, u.phone_number FROM users u WHERE u.email = 'customer@example.com';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.006921291351318359,0.0,0.0,0.0,98.2890625,98.2890625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
user_lookup_btree,btree,"SELECT u.user_id, u.email, u.first_name, u.last_name, u.phone_number FROM users u WHERE u.email = 'customer@example.com';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.00273895263671875,0.0,0.0,0.0,98.2890625,98.2890625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
user_lookup_bitmap,bitmap,"SELECT u.user_id, u.email, u.first_name, u.last_name, u.phone_number FROM users u WHERE u.email = 'customer@example.com';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.005705356597900391,0.0,0.0,0.0,98.2890625,98.2890625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
user_lookup_gist,gist,"SELECT u.user_id, u.email, u.first_name, u.last_name, u.phone_number FROM users u WHERE u.email = 'customer@example.com';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.005120277404785156,0.0,0.0,0.0,98.2890625,98.2890625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
user_lookup_reverse,reverse,"SELECT u.user_id, u.email, u.first_name, u.last_name, u.phone_number FROM users u WHERE u.email = 'customer@example.com';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.003049612045288086,0.0,0.0,0.0,98.2890625,98.2890625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
user_orders,hash,"SELECT u.user_id, u.first_name, u.last_name, u.email, o.order_id, o.order_date, o.total_amount, o.status FROM Users u JOIN Orders o ON u.user_id = o.user_id WHERE u.user_id = 5001 ORDER BY o.order_date DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.035759687423706055,0.0,0.0,0.0,98.2890625,98.2890625,0.0,48,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,
user_orders_btree,btree,"SELECT u.user_id, u.first_name, u.last_name, u.email, o.order_id, o.order_date, o.total_amount, o.status FROM Users u JOIN Orders o ON u.user_id = o.user_id WHERE u.user_id = 5001 ORDER BY o.order_date DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0038716793060302734,0.0,0.0,0.0,98.2890625,98.2890625,0.0,48,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,
user_orders_bitmap,bitmap,"SELECT u.user_id, u.first_name, u.last_name, u.email, o.order_id, o.order_date, o.total_amount, o.status FROM Users u JOIN Orders o ON u.user_id = o.user_id WHERE u.user_id = 5001 ORDER BY o.order_date DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.026134014129638672,0.0,0.0,0.0,98.2890625,98.2890625,0.0,48,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,
user_orders_gist,gist,"SELECT u.user_id, u.first_name, u.last_name, u.email, o.order_id, o.order_date, o.total_amount, o.status FROM Users u JOIN Orders o ON u.user_id = o.user_id WHERE u.user_id = 5001 ORDER BY o.order_date DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.028475522994995117,0.0,0.0,0.0,98.2890625,98.2890625,0.0,48,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,
user_orders_reverse,reverse,"SELECT u.user_id, u.first_name, u.last_name, u.email, o.order_id, o.order_date, o.total_amount, o.status FROM Users u JOIN Orders o ON u.user_id = o.user_id WHERE u.user_id = 5001 ORDER BY o.order_date DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.029623746871948242,0.0,0.0,0.0,98.2890625,98.2890625,0.0,48,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,
analytics_status_count,bitmap,"SELECT COUNT(*) as order_count, status FROM Orders WHERE order_date BETWEEN '2017-01-01' AND '2025-06-30' GROUP BY status;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.03908276557922363,0.0,0.0,0.0,98.2890625,98.2890625,0.0,4,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,
analytics_status_count_btree,btree,"SELECT COUNT(*) as order_count, status FROM Orders WHERE order_date BETWEEN '2017-01-01' AND '2025-06-30' GROUP BY status;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.049802303314208984,0.0,0.0,0.0,98.2890625,98.2890625,0.0,4,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,
analytics_status_count_hash,hash,"SELECT COUNT(*) as order_count, status FROM Orders WHERE order_date BETWEEN '2017-01-01' AND '2025-06-30' GROUP BY status;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.04787111282348633,0.0,0.0,0.0,98.2890625,98.2890625,0.0,4,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,
analytics_status_count_gist,gist,"SELECT COUNT(*) as order_count, status FROM Orders WHERE order_date BETWEEN '2017-01-01' AND '2025-06-30' GROUP BY status;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.038424015045166016,0.0,0.0,0.0,98.2890625,98.2890625,0.0,4,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,
analytics_status_count_reverse,reverse,"SELECT COUNT(*) as order_count, status FROM Orders WHERE order_date BETWEEN '2017-01-01' AND '2025-06-30' GROUP BY status;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.046262264251708984,0.0,0.0,0.0,98.2890625,98.2890625,0.0,4,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,
category_products,bitmap,"SELECT c.name as category_name, COUNT(p.product_id) as product_count, AVG(p.price) as avg_price FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id, c.name;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.002403736114501953,0.0,0.0,0.0,98.2890625,98.2890625,0.0,20,1,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,
category_products_btree,btree,"SELECT c.name as category_name, COUNT(p.product_id) as product_count, AVG(p.price) as avg_price FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id, c.name;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.006289482116699219,0.0,0.0,0.0,98.2890625,98.2890625,0.0,20,1,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,
category_products_hash,hash,"SELECT c.name as category_name, COUNT(p.product_id) as product_count, AVG(p.price) as avg_price FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id, c.name;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.005661725997924805,0.0,0.0,0.0,98.2890625,98.2890625,0.0,20,1,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,
category_products_gist,gist,"SELECT c.name as category_name, COUNT(p.product_id) as product_count, AVG(p.price) as avg_price FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id, c.name;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.007183074951171875,0.0,0.0,0.0,98.2890625,98.2890625,0.0,20,1,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,
category_products_reverse,reverse,"SELECT c.name as category_name, COUNT(p.product_id) as product_count, AVG(p.price) as avg_price FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id, c.name;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.005817890167236328,0.0,0.0,0.0,98.2890625,98.2890625,0.0,20,1,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,
cohort_analysis,bitmap,"WITH FirstPurchases AS ( SELECT u.user_id, TO_CHAR(MIN(o.order_date), 'YYYY-MM') AS cohort_month  -- Changed DATE_FORMAT to TO_CHAR FROM Users u JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id ), CustomerOrders AS ( SELECT fp.user_id, fp.cohort_month, TO_CHAR(o.order_date, 'YYYY-MM') AS order_month,  -- Changed DATE_FORMAT to TO_CHAR EXTRACT(YEAR FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) * 12 +  -- Calculate month difference EXTRACT(MONTH FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) AS month_number FROM FirstPurchases fp JOIN Orders o ON fp.user_id = o.user_id ), CohortSize AS ( SELECT cohort_month, COUNT(DISTINCT user_id) AS num_users FROM FirstPurchases GROUP BY cohort_month ), CohortRetention AS ( SELECT co.cohort_month, co.month_number, COUNT(DISTINCT co.user_id) AS num_users FROM CustomerOrders co GROUP BY co.cohort_month, co.month_number ) SELECT cr.cohort_month, cs.num_users AS cohort_size, cr.month_number, cr.num_users AS returning_users, (cr.num_users::float / cs.num_users) * 100 AS retention_rate  -- Ensure float division FROM CohortRetention cr JOIN CohortSize cs ON cr.cohort_month = cs.cohort_month WHERE cr.month_number <= 12 ORDER BY cr.cohort_month, cr.month_number;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...onth_number <= 12 ORDER BY cr.cohort_month, cr.month_number;
                                                                       ^
"
cohort_analysis_btree,btree,"WITH FirstPurchases AS ( SELECT u.user_id, TO_CHAR(MIN(o.order_date), 'YYYY-MM') AS cohort_month  -- Changed DATE_FORMAT to TO_CHAR FROM Users u JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id ), CustomerOrders AS ( SELECT fp.user_id, fp.cohort_month, TO_CHAR(o.order_date, 'YYYY-MM') AS order_month,  -- Changed DATE_FORMAT to TO_CHAR EXTRACT(YEAR FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) * 12 +  -- Calculate month difference EXTRACT(MONTH FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) AS month_number FROM FirstPurchases fp JOIN Orders o ON fp.user_id = o.user_id ), CohortSize AS ( SELECT cohort_month, COUNT(DISTINCT user_id) AS num_users FROM FirstPurchases GROUP BY cohort_month ), CohortRetention AS ( SELECT co.cohort_month, co.month_number, COUNT(DISTINCT co.user_id) AS num_users FROM CustomerOrders co GROUP BY co.cohort_month, co.month_number ) SELECT cr.cohort_month, cs.num_users AS cohort_size, cr.month_number, cr.num_users AS returning_users, (cr.num_users::float / cs.num_users) * 100 AS retention_rate  -- Ensure float division FROM CohortRetention cr JOIN CohortSize cs ON cr.cohort_month = cs.cohort_month WHERE cr.month_number <= 12 ORDER BY cr.cohort_month, cr.month_number;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...onth_number <= 12 ORDER BY cr.cohort_month, cr.month_number;
                                                                       ^
"
cohort_analysis_hash,hash,"WITH FirstPurchases AS ( SELECT u.user_id, TO_CHAR(MIN(o.order_date), 'YYYY-MM') AS cohort_month  -- Changed DATE_FORMAT to TO_CHAR FROM Users u JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id ), CustomerOrders AS ( SELECT fp.user_id, fp.cohort_month, TO_CHAR(o.order_date, 'YYYY-MM') AS order_month,  -- Changed DATE_FORMAT to TO_CHAR EXTRACT(YEAR FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) * 12 +  -- Calculate month difference EXTRACT(MONTH FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) AS month_number FROM FirstPurchases fp JOIN Orders o ON fp.user_id = o.user_id ), CohortSize AS ( SELECT cohort_month, COUNT(DISTINCT user_id) AS num_users FROM FirstPurchases GROUP BY cohort_month ), CohortRetention AS ( SELECT co.cohort_month, co.month_number, COUNT(DISTINCT co.user_id) AS num_users FROM CustomerOrders co GROUP BY co.cohort_month, co.month_number ) SELECT cr.cohort_month, cs.num_users AS cohort_size, cr.month_number, cr.num_users AS returning_users, (cr.num_users::float / cs.num_users) * 100 AS retention_rate  -- Ensure float division FROM CohortRetention cr JOIN CohortSize cs ON cr.cohort_month = cs.cohort_month WHERE cr.month_number <= 12 ORDER BY cr.cohort_month, cr.month_number;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...onth_number <= 12 ORDER BY cr.cohort_month, cr.month_number;
                                                                       ^
"
cohort_analysis_gist,gist,"WITH FirstPurchases AS ( SELECT u.user_id, TO_CHAR(MIN(o.order_date), 'YYYY-MM') AS cohort_month  -- Changed DATE_FORMAT to TO_CHAR FROM Users u JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id ), CustomerOrders AS ( SELECT fp.user_id, fp.cohort_month, TO_CHAR(o.order_date, 'YYYY-MM') AS order_month,  -- Changed DATE_FORMAT to TO_CHAR EXTRACT(YEAR FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) * 12 +  -- Calculate month difference EXTRACT(MONTH FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) AS month_number FROM FirstPurchases fp JOIN Orders o ON fp.user_id = o.user_id ), CohortSize AS ( SELECT cohort_month, COUNT(DISTINCT user_id) AS num_users FROM FirstPurchases GROUP BY cohort_month ), CohortRetention AS ( SELECT co.cohort_month, co.month_number, COUNT(DISTINCT co.user_id) AS num_users FROM CustomerOrders co GROUP BY co.cohort_month, co.month_number ) SELECT cr.cohort_month, cs.num_users AS cohort_size, cr.month_number, cr.num_users AS returning_users, (cr.num_users::float / cs.num_users) * 100 AS retention_rate  -- Ensure float division FROM CohortRetention cr JOIN CohortSize cs ON cr.cohort_month = cs.cohort_month WHERE cr.month_number <= 12 ORDER BY cr.cohort_month, cr.month_number;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...onth_number <= 12 ORDER BY cr.cohort_month, cr.month_number;
                                                                       ^
"
cohort_analysis_reverse,reverse,"WITH FirstPurchases AS ( SELECT u.user_id, TO_CHAR(MIN(o.order_date), 'YYYY-MM') AS cohort_month  -- Changed DATE_FORMAT to TO_CHAR FROM Users u JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id ), CustomerOrders AS ( SELECT fp.user_id, fp.cohort_month, TO_CHAR(o.order_date, 'YYYY-MM') AS order_month,  -- Changed DATE_FORMAT to TO_CHAR EXTRACT(YEAR FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) * 12 +  -- Calculate month difference EXTRACT(MONTH FROM AGE(o.order_date, TO_DATE(fp.cohort_month, 'YYYY-MM'))) AS month_number FROM FirstPurchases fp JOIN Orders o ON fp.user_id = o.user_id ), CohortSize AS ( SELECT cohort_month, COUNT(DISTINCT user_id) AS num_users FROM FirstPurchases GROUP BY cohort_month ), CohortRetention AS ( SELECT co.cohort_month, co.month_number, COUNT(DISTINCT co.user_id) AS num_users FROM CustomerOrders co GROUP BY co.cohort_month, co.month_number ) SELECT cr.cohort_month, cs.num_users AS cohort_size, cr.month_number, cr.num_users AS returning_users, (cr.num_users::float / cs.num_users) * 100 AS retention_rate  -- Ensure float division FROM CohortRetention cr JOIN CohortSize cs ON cr.cohort_month = cs.cohort_month WHERE cr.month_number <= 12 ORDER BY cr.cohort_month, cr.month_number;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at end of input
LINE 1: ...onth_number <= 12 ORDER BY cr.cohort_month, cr.month_number;
                                                                       ^
"
complex_and_or_filter,bitmap,"SELECT p.product_id, p.name, p.price, p.stock_quantity FROM Products p WHERE (p.category_id = 1 OR p.category_id = 2) AND (p.stock_quantity < 10 OR p.stock_quantity > 100);",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.006232500076293945,0.0,0.0,0.0,98.296875,98.296875,0.0,182,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
complex_and_or_filter_btree,btree,"SELECT p.product_id, p.name, p.price, p.stock_quantity FROM Products p WHERE (p.category_id = 1 OR p.category_id = 2) AND (p.stock_quantity < 10 OR p.stock_quantity > 100);",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0015048980712890625,0.0,0.0,0.0,98.296875,98.296875,0.0,182,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
complex_and_or_filter_hash,hash,"SELECT p.product_id, p.name, p.price, p.stock_quantity FROM Products p WHERE (p.category_id = 1 OR p.category_id = 2) AND (p.stock_quantity < 10 OR p.stock_quantity > 100);",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0059108734130859375,0.0,0.0,0.0,98.296875,98.296875,0.0,182,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
complex_and_or_filter_gist,gist,"SELECT p.product_id, p.name, p.price, p.stock_quantity FROM Products p WHERE (p.category_id = 1 OR p.category_id = 2) AND (p.stock_quantity < 10 OR p.stock_quantity > 100);",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.005870819091796875,0.0,0.0,0.0,98.296875,98.296875,0.0,182,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
complex_and_or_filter_reverse,reverse,"SELECT p.product_id, p.name, p.price, p.stock_quantity FROM Products p WHERE (p.category_id = 1 OR p.category_id = 2) AND (p.stock_quantity < 10 OR p.stock_quantity > 100);",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0021376609802246094,0.0,0.0,0.0,98.30078125,98.30078125,0.0,182,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
delivery_status_metrics,bitmap,"SELECT status, COUNT(*) as order_count, AVG(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - order_date))/86400) as avg_days_in_status, MIN(total_amount) as min_order_value, MAX(total_amount) as max_order_value, AVG(total_amount) as avg_order_value FROM orders GROUP BY status;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.09653472900390625,0.0,0.0,0.0,98.30078125,98.30078125,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,3,0,
delivery_status_metrics_btree,btree,"SELECT status, COUNT(*) as order_count, AVG(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - order_date))/86400) as avg_days_in_status, MIN(total_amount) as min_order_value, MAX(total_amount) as max_order_value, AVG(total_amount) as avg_order_value FROM orders GROUP BY status;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.09278202056884766,0.0,0.0,0.0,98.30078125,98.30078125,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,3,0,
delivery_status_metrics_hash,hash,"SELECT status, COUNT(*) as order_count, AVG(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - order_date))/86400) as avg_days_in_status, MIN(total_amount) as min_order_value, MAX(total_amount) as max_order_value, AVG(total_amount) as avg_order_value FROM orders GROUP BY status;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.09173154830932617,0.0,0.0,0.0,98.30078125,98.30078125,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,3,0,
delivery_status_metrics_gist,gist,"SELECT status, COUNT(*) as order_count, AVG(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - order_date))/86400) as avg_days_in_status, MIN(total_amount) as min_order_value, MAX(total_amount) as max_order_value, AVG(total_amount) as avg_order_value FROM orders GROUP BY status;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.09568953514099121,0.0,0.0,0.0,98.30078125,98.30078125,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,3,0,
delivery_status_metrics_reverse,reverse,"SELECT status, COUNT(*) as order_count, AVG(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - order_date))/86400) as avg_days_in_status, MIN(total_amount) as min_order_value, MAX(total_amount) as max_order_value, AVG(total_amount) as avg_order_value FROM orders GROUP BY status;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.12239909172058105,0.0,0.0,0.0,98.30078125,98.30078125,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,3,0,
monthly_order_status,bitmap,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as orders FROM orders GROUP BY month, status ORDER BY month, status;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.12035322189331055,0.0,0.0,0.0,98.30078125,98.30078125,0.0,432,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
monthly_order_status_btree,btree,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as orders FROM orders GROUP BY month, status ORDER BY month, status;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.11219143867492676,0.0,0.0,0.0,98.30078125,98.30078125,0.0,432,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
monthly_order_status_hash,hash,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as orders FROM orders GROUP BY month, status ORDER BY month, status;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.10901784896850586,0.0,0.0,0.0,98.30078125,98.30078125,0.0,432,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
monthly_order_status_gist,gist,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as orders FROM orders GROUP BY month, status ORDER BY month, status;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.1107785701751709,0.0,0.0,0.0,98.30078125,98.30078125,0.0,432,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
monthly_order_status_reverse,reverse,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as orders FROM orders GROUP BY month, status ORDER BY month, status;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.11115145683288574,0.0,0.0,0.0,98.30078125,98.30078125,0.0,432,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
multiple_status_or,bitmap,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Pending' OR status = 'Shipped';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.36275386810302734,0.0,0.0,0.0,98.30078125,164.83203125,66.53125,237361,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
multiple_status_or_btree,btree,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Pending' OR status = 'Shipped';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.31163549423217773,0.0,0.0,0.0,100.3828125,164.5546875,64.171875,237361,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
multiple_status_or_hash,hash,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Pending' OR status = 'Shipped';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.31380701065063477,0.0,0.0,0.0,101.3984375,164.23046875,62.83203125,237361,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
multiple_status_or_gist,gist,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Pending' OR status = 'Shipped';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.2923862934112549,0.0,0.0,0.0,103.171875,164.37109375,61.19921875,237361,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
multiple_status_or_reverse,reverse,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Pending' OR status = 'Shipped';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.2932264804840088,0.0,0.0,0.0,104.42578125,164.37109375,59.9453125,237361,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
order_status_analysis,bitmap,"SELECT status, COUNT(*) AS order_count, SUM(total_amount) AS total_revenue, AVG(total_amount) AS average_order_value, MIN(order_date) AS earliest_order, MAX(order_date) AS latest_order FROM Orders WHERE status IN ('Pending', 'Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY status ORDER BY order_count DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.028460264205932617,0.0,0.0,0.0,104.625,104.625,0.0,3,1,0,0,0,0,0,0,0,1,1,1,0,0,1,3,0,
order_status_analysis_btree,btree,"SELECT status, COUNT(*) AS order_count, SUM(total_amount) AS total_revenue, AVG(total_amount) AS average_order_value, MIN(order_date) AS earliest_order, MAX(order_date) AS latest_order FROM Orders WHERE status IN ('Pending', 'Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY status ORDER BY order_count DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.01844334602355957,0.0,0.0,0.0,104.625,104.625,0.0,3,1,0,0,0,0,0,0,0,1,1,1,0,0,1,3,0,
order_status_analysis_hash,hash,"SELECT status, COUNT(*) AS order_count, SUM(total_amount) AS total_revenue, AVG(total_amount) AS average_order_value, MIN(order_date) AS earliest_order, MAX(order_date) AS latest_order FROM Orders WHERE status IN ('Pending', 'Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY status ORDER BY order_count DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.02774524688720703,0.0,0.0,0.0,104.625,104.625,0.0,3,1,0,0,0,0,0,0,0,1,1,1,0,0,1,3,0,
order_status_analysis_gist,gist,"SELECT status, COUNT(*) AS order_count, SUM(total_amount) AS total_revenue, AVG(total_amount) AS average_order_value, MIN(order_date) AS earliest_order, MAX(order_date) AS latest_order FROM Orders WHERE status IN ('Pending', 'Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY status ORDER BY order_count DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.016937255859375,0.0,0.0,0.0,104.625,104.625,0.0,3,1,0,0,0,0,0,0,0,1,1,1,0,0,1,3,0,
order_status_analysis_reverse,reverse,"SELECT status, COUNT(*) AS order_count, SUM(total_amount) AS total_revenue, AVG(total_amount) AS average_order_value, MIN(order_date) AS earliest_order, MAX(order_date) AS latest_order FROM Orders WHERE status IN ('Pending', 'Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY status ORDER BY order_count DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.02776622772216797,0.0,0.0,0.0,104.625,104.625,0.0,3,1,0,0,0,0,0,0,0,1,1,1,0,0,1,3,0,
order_status_by_month,bitmap,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as order_count, SUM(total_amount) as total_revenue, AVG(total_amount) as avg_order_value FROM orders WHERE status IN ('Pending', 'Shipped', 'Delivered') GROUP BY month, status ORDER BY month DESC, status;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.12645888328552246,0.0,0.0,0.0,104.625,104.625,0.0,324,1,0,0,0,0,0,0,0,1,1,1,0,0,0,2,0,
order_status_by_month_btree,btree,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as order_count, SUM(total_amount) as total_revenue, AVG(total_amount) as avg_order_value FROM orders WHERE status IN ('Pending', 'Shipped', 'Delivered') GROUP BY month, status ORDER BY month DESC, status;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.12469124794006348,0.0,0.0,0.0,104.625,104.625,0.0,324,1,0,0,0,0,0,0,0,1,1,1,0,0,0,2,0,
order_status_by_month_hash,hash,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as order_count, SUM(total_amount) as total_revenue, AVG(total_amount) as avg_order_value FROM orders WHERE status IN ('Pending', 'Shipped', 'Delivered') GROUP BY month, status ORDER BY month DESC, status;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.12885355949401855,0.0,0.0,0.0,104.625,104.625,0.0,324,1,0,0,0,0,0,0,0,1,1,1,0,0,0,2,0,
order_status_by_month_gist,gist,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as order_count, SUM(total_amount) as total_revenue, AVG(total_amount) as avg_order_value FROM orders WHERE status IN ('Pending', 'Shipped', 'Delivered') GROUP BY month, status ORDER BY month DESC, status;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.12594103813171387,0.0,0.0,0.0,104.625,104.625,0.0,324,1,0,0,0,0,0,0,0,1,1,1,0,0,0,2,0,
order_status_by_month_reverse,reverse,"SELECT DATE_TRUNC('month', order_date) as month, status, COUNT(*) as order_count, SUM(total_amount) as total_revenue, AVG(total_amount) as avg_order_value FROM orders WHERE status IN ('Pending', 'Shipped', 'Delivered') GROUP BY month, status ORDER BY month DESC, status;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.1336531639099121,0.0,0.0,0.0,104.625,104.625,0.0,324,1,0,0,0,0,0,0,0,1,1,1,0,0,0,2,0,
order_status_query,bitmap,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Delivered';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.14576268196105957,0.0,0.0,0.0,104.625,125.96875,21.34375,118757,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
order_status_query_btree,btree,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Delivered';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.16220927238464355,0.0,0.0,0.0,105.046875,126.046875,21.0,118757,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
order_status_query_hash,hash,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Delivered';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.16300249099731445,0.0,0.0,0.0,107.92578125,125.9609375,18.03515625,118757,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
order_status_query_gist,gist,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Delivered';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.1725625991821289,0.0,0.0,0.0,108.60546875,125.95703125,17.3515625,118757,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
order_status_query_reverse,reverse,"SELECT order_id, user_id, order_date, status FROM Orders WHERE status = 'Delivered';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.15552449226379395,0.0,0.0,0.0,108.96875,126.20703125,17.23828125,118757,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
order_status_summary,bitmap,"SELECT status, COUNT(*) as order_count, SUM(total_amount) as total_revenue FROM orders GROUP BY status ORDER BY order_count DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.054780006408691406,0.0,0.0,0.0,110.9453125,110.9453125,0.0,4,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
order_status_summary_btree,btree,"SELECT status, COUNT(*) as order_count, SUM(total_amount) as total_revenue FROM orders GROUP BY status ORDER BY order_count DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.05215001106262207,0.0,0.0,0.0,110.9453125,110.9453125,0.0,4,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
order_status_summary_hash,hash,"SELECT status, COUNT(*) as order_count, SUM(total_amount) as total_revenue FROM orders GROUP BY status ORDER BY order_count DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.04676699638366699,0.0,0.0,0.0,110.9453125,110.9453125,0.0,4,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
order_status_summary_gist,gist,"SELECT status, COUNT(*) as order_count, SUM(total_amount) as total_revenue FROM orders GROUP BY status ORDER BY order_count DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.04752397537231445,0.0,0.0,0.0,110.9453125,110.9453125,0.0,4,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
order_status_summary_reverse,reverse,"SELECT status, COUNT(*) as order_count, SUM(total_amount) as total_revenue FROM orders GROUP BY status ORDER BY order_count DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.043964385986328125,0.0,0.0,0.0,110.9453125,110.9453125,0.0,4,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
product_performance_analysis,bitmap,"SELECT p.product_id, p.name, c.name AS category_name, SUM(oi.quantity) AS total_units_sold, SUM(oi.quantity * oi.price) AS total_revenue, AVG(oi.price) AS avg_selling_price, COUNT(DISTINCT o.order_id) AS appearance_in_orders, COUNT(DISTINCT o.user_id) AS unique_customers, SUM(oi.quantity) / COUNT(DISTINCT o.order_id) AS avg_quantity_per_order, SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) AS cancelled_units, (SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) / NULLIF(SUM(oi.quantity), 0)) * 100 AS cancellation_rate, RANK() OVER (PARTITION BY c.category_id ORDER BY SUM(oi.quantity) DESC) AS rank_in_category, PERCENT_RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) AS percentile_rank_overall FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id GROUP BY p.product_id, p.name, c.name, c.category_id ORDER BY total_revenue DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),2.5149343013763428,0.0,0.0,0.0,110.9453125,111.5234375,0.578125,2000,1,0,0,0,0,0,0,3,0,1,3,0,0,0,9,0,
product_performance_analysis_btree,btree,"SELECT p.product_id, p.name, c.name AS category_name, SUM(oi.quantity) AS total_units_sold, SUM(oi.quantity * oi.price) AS total_revenue, AVG(oi.price) AS avg_selling_price, COUNT(DISTINCT o.order_id) AS appearance_in_orders, COUNT(DISTINCT o.user_id) AS unique_customers, SUM(oi.quantity) / COUNT(DISTINCT o.order_id) AS avg_quantity_per_order, SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) AS cancelled_units, (SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) / NULLIF(SUM(oi.quantity), 0)) * 100 AS cancellation_rate, RANK() OVER (PARTITION BY c.category_id ORDER BY SUM(oi.quantity) DESC) AS rank_in_category, PERCENT_RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) AS percentile_rank_overall FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id GROUP BY p.product_id, p.name, c.name, c.category_id ORDER BY total_revenue DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),2.5003116130828857,0.0,0.0,0.0,111.5234375,111.53515625,0.01171875,2000,1,0,0,0,0,0,0,3,0,1,3,0,0,0,9,0,
product_performance_analysis_hash,hash,"SELECT p.product_id, p.name, c.name AS category_name, SUM(oi.quantity) AS total_units_sold, SUM(oi.quantity * oi.price) AS total_revenue, AVG(oi.price) AS avg_selling_price, COUNT(DISTINCT o.order_id) AS appearance_in_orders, COUNT(DISTINCT o.user_id) AS unique_customers, SUM(oi.quantity) / COUNT(DISTINCT o.order_id) AS avg_quantity_per_order, SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) AS cancelled_units, (SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) / NULLIF(SUM(oi.quantity), 0)) * 100 AS cancellation_rate, RANK() OVER (PARTITION BY c.category_id ORDER BY SUM(oi.quantity) DESC) AS rank_in_category, PERCENT_RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) AS percentile_rank_overall FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id GROUP BY p.product_id, p.name, c.name, c.category_id ORDER BY total_revenue DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),2.4703335762023926,0.0,0.0,0.0,111.53515625,111.53515625,0.0,2000,1,0,0,0,0,0,0,3,0,1,3,0,0,0,9,0,
product_performance_analysis_gist,gist,"SELECT p.product_id, p.name, c.name AS category_name, SUM(oi.quantity) AS total_units_sold, SUM(oi.quantity * oi.price) AS total_revenue, AVG(oi.price) AS avg_selling_price, COUNT(DISTINCT o.order_id) AS appearance_in_orders, COUNT(DISTINCT o.user_id) AS unique_customers, SUM(oi.quantity) / COUNT(DISTINCT o.order_id) AS avg_quantity_per_order, SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) AS cancelled_units, (SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) / NULLIF(SUM(oi.quantity), 0)) * 100 AS cancellation_rate, RANK() OVER (PARTITION BY c.category_id ORDER BY SUM(oi.quantity) DESC) AS rank_in_category, PERCENT_RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) AS percentile_rank_overall FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id GROUP BY p.product_id, p.name, c.name, c.category_id ORDER BY total_revenue DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),2.467996835708618,0.0,0.0,0.0,111.53515625,111.53515625,0.0,2000,1,0,0,0,0,0,0,3,0,1,3,0,0,0,9,0,
product_performance_analysis_reverse,reverse,"SELECT p.product_id, p.name, c.name AS category_name, SUM(oi.quantity) AS total_units_sold, SUM(oi.quantity * oi.price) AS total_revenue, AVG(oi.price) AS avg_selling_price, COUNT(DISTINCT o.order_id) AS appearance_in_orders, COUNT(DISTINCT o.user_id) AS unique_customers, SUM(oi.quantity) / COUNT(DISTINCT o.order_id) AS avg_quantity_per_order, SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) AS cancelled_units, (SUM(CASE WHEN o.status = 'Cancelled' THEN oi.quantity ELSE 0 END) / NULLIF(SUM(oi.quantity), 0)) * 100 AS cancellation_rate, RANK() OVER (PARTITION BY c.category_id ORDER BY SUM(oi.quantity) DESC) AS rank_in_category, PERCENT_RANK() OVER (ORDER BY SUM(oi.quantity * oi.price) DESC) AS percentile_rank_overall FROM Products p JOIN Categories c ON p.category_id = c.category_id LEFT JOIN OrderItems oi ON p.product_id = oi.product_id LEFT JOIN Orders o ON oi.order_id = o.order_id GROUP BY p.product_id, p.name, c.name, c.category_id ORDER BY total_revenue DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),2.5052266120910645,0.0,0.0,0.0,111.53515625,111.53515625,0.0,2000,1,0,0,0,0,0,0,3,0,1,3,0,0,0,9,0,
product_stock_analysis,bitmap,"SELECT c.name as category, CASE WHEN p.stock_quantity = 0 THEN 'Out of Stock' WHEN p.stock_quantity <= 10 THEN 'Critical' WHEN p.stock_quantity <= 50 THEN 'Low' WHEN p.stock_quantity <= 100 THEN 'Medium' ELSE 'High' END as stock_level, COUNT(*) as product_count, SUM(p.stock_quantity) as total_stock FROM products p JOIN categories c ON p.category_id = c.category_id GROUP BY c.name, stock_level ORDER BY c.name, stock_level;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0034224987030029297,0.0,0.0,0.0,111.53515625,111.53515625,0.0,77,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
product_stock_analysis_btree,btree,"SELECT c.name as category, CASE WHEN p.stock_quantity = 0 THEN 'Out of Stock' WHEN p.stock_quantity <= 10 THEN 'Critical' WHEN p.stock_quantity <= 50 THEN 'Low' WHEN p.stock_quantity <= 100 THEN 'Medium' ELSE 'High' END as stock_level, COUNT(*) as product_count, SUM(p.stock_quantity) as total_stock FROM products p JOIN categories c ON p.category_id = c.category_id GROUP BY c.name, stock_level ORDER BY c.name, stock_level;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.006870746612548828,0.0,0.0,0.0,111.53515625,111.53515625,0.0,77,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
product_stock_analysis_hash,hash,"SELECT c.name as category, CASE WHEN p.stock_quantity = 0 THEN 'Out of Stock' WHEN p.stock_quantity <= 10 THEN 'Critical' WHEN p.stock_quantity <= 50 THEN 'Low' WHEN p.stock_quantity <= 100 THEN 'Medium' ELSE 'High' END as stock_level, COUNT(*) as product_count, SUM(p.stock_quantity) as total_stock FROM products p JOIN categories c ON p.category_id = c.category_id GROUP BY c.name, stock_level ORDER BY c.name, stock_level;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.006760835647583008,0.0,0.0,0.0,111.53515625,111.53515625,0.0,77,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
product_stock_analysis_gist,gist,"SELECT c.name as category, CASE WHEN p.stock_quantity = 0 THEN 'Out of Stock' WHEN p.stock_quantity <= 10 THEN 'Critical' WHEN p.stock_quantity <= 50 THEN 'Low' WHEN p.stock_quantity <= 100 THEN 'Medium' ELSE 'High' END as stock_level, COUNT(*) as product_count, SUM(p.stock_quantity) as total_stock FROM products p JOIN categories c ON p.category_id = c.category_id GROUP BY c.name, stock_level ORDER BY c.name, stock_level;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.00425410270690918,0.0,0.0,0.0,111.53515625,111.53515625,0.0,77,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
product_stock_analysis_reverse,reverse,"SELECT c.name as category, CASE WHEN p.stock_quantity = 0 THEN 'Out of Stock' WHEN p.stock_quantity <= 10 THEN 'Critical' WHEN p.stock_quantity <= 50 THEN 'Low' WHEN p.stock_quantity <= 100 THEN 'Medium' ELSE 'High' END as stock_level, COUNT(*) as product_count, SUM(p.stock_quantity) as total_stock FROM products p JOIN categories c ON p.category_id = c.category_id GROUP BY c.name, stock_level ORDER BY c.name, stock_level;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.003693819046020508,0.0,0.0,0.0,111.53515625,111.53515625,0.0,77,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,
stock_status,bitmap,"SELECT CASE WHEN stock_quantity = 0 THEN 'Out of Stock' WHEN stock_quantity < 10 THEN 'Low Stock' WHEN stock_quantity < 50 THEN 'Medium Stock' ELSE 'Well Stocked' END as stock_status, COUNT(*) as product_count FROM products GROUP BY stock_status;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.006530284881591797,0.0,0.0,0.0,111.53515625,111.53515625,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
stock_status_btree,btree,"SELECT CASE WHEN stock_quantity = 0 THEN 'Out of Stock' WHEN stock_quantity < 10 THEN 'Low Stock' WHEN stock_quantity < 50 THEN 'Medium Stock' ELSE 'Well Stocked' END as stock_status, COUNT(*) as product_count FROM products GROUP BY stock_status;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.005643606185913086,0.0,0.0,0.0,111.53515625,111.53515625,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
stock_status_hash,hash,"SELECT CASE WHEN stock_quantity = 0 THEN 'Out of Stock' WHEN stock_quantity < 10 THEN 'Low Stock' WHEN stock_quantity < 50 THEN 'Medium Stock' ELSE 'Well Stocked' END as stock_status, COUNT(*) as product_count FROM products GROUP BY stock_status;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0035665035247802734,0.0,0.0,0.0,111.53515625,111.53515625,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
stock_status_gist,gist,"SELECT CASE WHEN stock_quantity = 0 THEN 'Out of Stock' WHEN stock_quantity < 10 THEN 'Low Stock' WHEN stock_quantity < 50 THEN 'Medium Stock' ELSE 'Well Stocked' END as stock_status, COUNT(*) as product_count FROM products GROUP BY stock_status;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.005731105804443359,0.0,0.0,0.0,111.53515625,111.53515625,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
stock_status_reverse,reverse,"SELECT CASE WHEN stock_quantity = 0 THEN 'Out of Stock' WHEN stock_quantity < 10 THEN 'Low Stock' WHEN stock_quantity < 50 THEN 'Medium Stock' ELSE 'Well Stocked' END as stock_status, COUNT(*) as product_count FROM products GROUP BY stock_status;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0025451183319091797,0.0,0.0,0.0,111.53515625,111.53515625,0.0,4,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
address_ending,reverse,"SELECT user_id, shipping_address FROM users WHERE shipping_address LIKE '%NY 10001';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.004420280456542969,0.0,0.0,0.0,111.53515625,111.53515625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
address_ending_btree,btree,"SELECT user_id, shipping_address FROM users WHERE shipping_address LIKE '%NY 10001';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0036690235137939453,0.0,0.0,0.0,111.53515625,111.53515625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
address_ending_hash,hash,"SELECT user_id, shipping_address FROM users WHERE shipping_address LIKE '%NY 10001';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0035195350646972656,0.0,0.0,0.0,111.53515625,111.53515625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
address_ending_bitmap,bitmap,"SELECT user_id, shipping_address FROM users WHERE shipping_address LIKE '%NY 10001';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0044384002685546875,0.0,0.0,0.0,111.53515625,111.53515625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
address_ending_gist,gist,"SELECT user_id, shipping_address FROM users WHERE shipping_address LIKE '%NY 10001';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0061876773834228516,0.0,0.0,0.0,111.53515625,111.53515625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
address_postal_search,reverse,"SELECT SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC; SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""LIMIT""
LINE 1: ...AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) a...
                                                             ^
"
address_postal_search_btree,btree,"SELECT SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC; SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""LIMIT""
LINE 1: ...AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) a...
                                                             ^
"
address_postal_search_hash,hash,"SELECT SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC; SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""LIMIT""
LINE 1: ...AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) a...
                                                             ^
"
address_postal_search_bitmap,bitmap,"SELECT SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC; SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""LIMIT""
LINE 1: ...AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) a...
                                                             ^
"
address_postal_search_gist,gist,"SELECT SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC; SUBSTRING(shipping_address FROM '\d{5}$') as postal_code, COUNT(*) as customer_count, STRING_AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) as sample_customers FROM users WHERE shipping_address ~ '\d{5}$' GROUP BY postal_code ORDER BY customer_count DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""LIMIT""
LINE 1: ...AGG(DISTINCT first_name || ' ' || last_name, ', ' LIMIT 5) a...
                                                             ^
"
customer_domain_analysis,reverse,"SELECT SUBSTRING(email FROM '@(.*)$') as email_domain, COUNT(*) as user_count, COUNT(DISTINCT o.order_id) as total_orders, SUM(o.total_amount) as total_revenue FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY email_domain ORDER BY user_count DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),1.3947231769561768,0.0,0.0,0.0,111.53515625,111.53515625,0.0,3,1,0,0,0,0,0,0,1,0,1,1,0,0,0,5,0,
customer_domain_analysis_btree,btree,"SELECT SUBSTRING(email FROM '@(.*)$') as email_domain, COUNT(*) as user_count, COUNT(DISTINCT o.order_id) as total_orders, SUM(o.total_amount) as total_revenue FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY email_domain ORDER BY user_count DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),1.3498022556304932,0.0,0.0,0.0,111.53515625,111.53515625,0.0,3,1,0,0,0,0,0,0,1,0,1,1,0,0,0,5,0,
customer_domain_analysis_hash,hash,"SELECT SUBSTRING(email FROM '@(.*)$') as email_domain, COUNT(*) as user_count, COUNT(DISTINCT o.order_id) as total_orders, SUM(o.total_amount) as total_revenue FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY email_domain ORDER BY user_count DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),1.3567209243774414,0.0,0.0,0.0,111.53515625,111.53515625,0.0,3,1,0,0,0,0,0,0,1,0,1,1,0,0,0,5,0,
customer_domain_analysis_bitmap,bitmap,"SELECT SUBSTRING(email FROM '@(.*)$') as email_domain, COUNT(*) as user_count, COUNT(DISTINCT o.order_id) as total_orders, SUM(o.total_amount) as total_revenue FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY email_domain ORDER BY user_count DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),1.3574175834655762,0.0,0.0,0.0,111.53515625,111.53515625,0.0,3,1,0,0,0,0,0,0,1,0,1,1,0,0,0,5,0,
customer_domain_analysis_gist,gist,"SELECT SUBSTRING(email FROM '@(.*)$') as email_domain, COUNT(*) as user_count, COUNT(DISTINCT o.order_id) as total_orders, SUM(o.total_amount) as total_revenue FROM users u LEFT JOIN orders o ON u.user_id = o.user_id GROUP BY email_domain ORDER BY user_count DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),1.3551664352416992,0.0,0.0,0.0,111.53515625,111.53515625,0.0,3,1,0,0,0,0,0,0,1,0,1,1,0,0,0,5,0,
email_domain_search,reverse,"SELECT user_id, email, first_name, last_name FROM users WHERE email LIKE '%@gmail.com';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.003640413284301758,0.0,0.0,0.0,111.53515625,111.53515625,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
email_domain_search_btree,btree,"SELECT user_id, email, first_name, last_name FROM users WHERE email LIKE '%@gmail.com';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.0031528472900390625,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
email_domain_search_hash,hash,"SELECT user_id, email, first_name, last_name FROM users WHERE email LIKE '%@gmail.com';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.003709554672241211,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
email_domain_search_bitmap,bitmap,"SELECT user_id, email, first_name, last_name FROM users WHERE email LIKE '%@gmail.com';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0031118392944335938,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
email_domain_search_gist,gist,"SELECT user_id, email, first_name, last_name FROM users WHERE email LIKE '%@gmail.com';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.006489992141723633,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
inactive_users,reverse,"SELECT u.user_id, u.first_name, u.last_name, u.email, u.created_at AS registration_date, MAX(o.order_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) AS days_since_last_order, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, SUM(o.total_amount) / COUNT(DISTINCT o.order_id) AS average_order_value FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.first_name, u.last_name, u.email, u.created_at HAVING MAX(o.order_date) IS NULL OR DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) > 90 ORDER BY days_since_last_order DESC NULLS FIRST;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""(""
LINE 1: ...er_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o....
                                                             ^
"
inactive_users_btree,btree,"SELECT u.user_id, u.first_name, u.last_name, u.email, u.created_at AS registration_date, MAX(o.order_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) AS days_since_last_order, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, SUM(o.total_amount) / COUNT(DISTINCT o.order_id) AS average_order_value FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.first_name, u.last_name, u.email, u.created_at HAVING MAX(o.order_date) IS NULL OR DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) > 90 ORDER BY days_since_last_order DESC NULLS FIRST;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""(""
LINE 1: ...er_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o....
                                                             ^
"
inactive_users_hash,hash,"SELECT u.user_id, u.first_name, u.last_name, u.email, u.created_at AS registration_date, MAX(o.order_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) AS days_since_last_order, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, SUM(o.total_amount) / COUNT(DISTINCT o.order_id) AS average_order_value FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.first_name, u.last_name, u.email, u.created_at HAVING MAX(o.order_date) IS NULL OR DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) > 90 ORDER BY days_since_last_order DESC NULLS FIRST;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""(""
LINE 1: ...er_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o....
                                                             ^
"
inactive_users_bitmap,bitmap,"SELECT u.user_id, u.first_name, u.last_name, u.email, u.created_at AS registration_date, MAX(o.order_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) AS days_since_last_order, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, SUM(o.total_amount) / COUNT(DISTINCT o.order_id) AS average_order_value FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.first_name, u.last_name, u.email, u.created_at HAVING MAX(o.order_date) IS NULL OR DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) > 90 ORDER BY days_since_last_order DESC NULLS FIRST;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""(""
LINE 1: ...er_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o....
                                                             ^
"
inactive_users_gist,gist,"SELECT u.user_id, u.first_name, u.last_name, u.email, u.created_at AS registration_date, MAX(o.order_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) AS days_since_last_order, COUNT(DISTINCT o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, SUM(o.total_amount) / COUNT(DISTINCT o.order_id) AS average_order_value FROM Users u LEFT JOIN Orders o ON u.user_id = o.user_id GROUP BY u.user_id, u.first_name, u.last_name, u.email, u.created_at HAVING MAX(o.order_date) IS NULL OR DATEDIFF(CURRENT_DATE(), MAX(o.order_date)) > 90 ORDER BY days_since_last_order DESC NULLS FIRST;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"syntax error at or near ""(""
LINE 1: ...er_date) AS last_order_date, DATEDIFF(CURRENT_DATE(), MAX(o....
                                                             ^
"
multi_table_query,reverse,"SELECT o.order_id, o.order_date, u.email FROM Orders o JOIN Users u ON o.user_id = u.user_id WHERE o.order_id = 45678;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0069544315338134766,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
multi_table_query_btree,btree,"SELECT o.order_id, o.order_date, u.email FROM Orders o JOIN Users u ON o.user_id = u.user_id WHERE o.order_id = 45678;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.007021427154541016,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
multi_table_query_hash,hash,"SELECT o.order_id, o.order_date, u.email FROM Orders o JOIN Users u ON o.user_id = u.user_id WHERE o.order_id = 45678;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0025734901428222656,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
multi_table_query_bitmap,bitmap,"SELECT o.order_id, o.order_date, u.email FROM Orders o JOIN Users u ON o.user_id = u.user_id WHERE o.order_id = 45678;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0022885799407958984,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
multi_table_query_gist,gist,"SELECT o.order_id, o.order_date, u.email FROM Orders o JOIN Users u ON o.user_id = u.user_id WHERE o.order_id = 45678;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0014226436614990234,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,
numeric_id_query,reverse,"SELECT user_id, first_name, last_name, email FROM Users WHERE user_id = 1233;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0017752647399902344,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
numeric_id_query_btree,btree,"SELECT user_id, first_name, last_name, email FROM Users WHERE user_id = 1233;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.006181478500366211,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
numeric_id_query_hash,hash,"SELECT user_id, first_name, last_name, email FROM Users WHERE user_id = 1233;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.004555225372314453,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
numeric_id_query_bitmap,bitmap,"SELECT user_id, first_name, last_name, email FROM Users WHERE user_id = 1233;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0030994415283203125,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
numeric_id_query_gist,gist,"SELECT user_id, first_name, last_name, email FROM Users WHERE user_id = 1233;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0017042160034179688,0.0,0.0,0.0,111.55078125,111.55078125,0.0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
phone_area_code,reverse,"SELECT user_id, phone_number, email FROM users WHERE phone_number LIKE '212%';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.005936861038208008,0.0,0.0,0.0,111.55078125,111.55078125,0.0,2,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
phone_area_code_btree,btree,"SELECT user_id, phone_number, email FROM users WHERE phone_number LIKE '212%';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.005236625671386719,0.0,0.0,0.0,111.55078125,111.55078125,0.0,2,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
phone_area_code_hash,hash,"SELECT user_id, phone_number, email FROM users WHERE phone_number LIKE '212%';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0022284984588623047,0.0,0.0,0.0,111.55078125,111.55078125,0.0,2,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
phone_area_code_bitmap,bitmap,"SELECT user_id, phone_number, email FROM users WHERE phone_number LIKE '212%';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.006126880645751953,0.0,0.0,0.0,111.55078125,111.55078125,0.0,2,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
phone_area_code_gist,gist,"SELECT user_id, phone_number, email FROM users WHERE phone_number LIKE '212%';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.005841732025146484,0.0,0.0,0.0,111.55078125,111.55078125,0.0,2,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
product_model_search,reverse,"SELECT p.product_id, p.name, p.price, p.stock_quantity, COUNT(oi.order_item_id) as times_ordered FROM products p LEFT JOIN orderitems oi ON p.product_id = oi.product_id WHERE p.name LIKE '% 2023' GROUP BY p.product_id, p.name, p.price, p.stock_quantity;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0032911300659179688,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,
product_model_search_btree,btree,"SELECT p.product_id, p.name, p.price, p.stock_quantity, COUNT(oi.order_item_id) as times_ordered FROM products p LEFT JOIN orderitems oi ON p.product_id = oi.product_id WHERE p.name LIKE '% 2023' GROUP BY p.product_id, p.name, p.price, p.stock_quantity;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.006392240524291992,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,
product_model_search_hash,hash,"SELECT p.product_id, p.name, p.price, p.stock_quantity, COUNT(oi.order_item_id) as times_ordered FROM products p LEFT JOIN orderitems oi ON p.product_id = oi.product_id WHERE p.name LIKE '% 2023' GROUP BY p.product_id, p.name, p.price, p.stock_quantity;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.004927873611450195,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,
product_model_search_bitmap,bitmap,"SELECT p.product_id, p.name, p.price, p.stock_quantity, COUNT(oi.order_item_id) as times_ordered FROM products p LEFT JOIN orderitems oi ON p.product_id = oi.product_id WHERE p.name LIKE '% 2023' GROUP BY p.product_id, p.name, p.price, p.stock_quantity;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0028619766235351562,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,
product_model_search_gist,gist,"SELECT p.product_id, p.name, p.price, p.stock_quantity, COUNT(oi.order_item_id) as times_ordered FROM products p LEFT JOIN orderitems oi ON p.product_id = oi.product_id WHERE p.name LIKE '% 2023' GROUP BY p.product_id, p.name, p.price, p.stock_quantity;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.002087116241455078,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,
product_name_suffix,reverse,"SELECT product_id, name, price FROM products WHERE name LIKE '%Pro';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0018684864044189453,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
product_name_suffix_btree,btree,"SELECT product_id, name, price FROM products WHERE name LIKE '%Pro';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.005160093307495117,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
product_name_suffix_hash,hash,"SELECT product_id, name, price FROM products WHERE name LIKE '%Pro';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0026178359985351562,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
product_name_suffix_bitmap,bitmap,"SELECT product_id, name, price FROM products WHERE name LIKE '%Pro';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0035009384155273438,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
product_name_suffix_gist,gist,"SELECT product_id, name, price FROM products WHERE name LIKE '%Pro';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0028388500213623047,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
range_id_query,reverse,"SELECT order_id, order_date, status FROM Orders WHERE order_id BETWEEN 5000 AND 5100;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.0024557113647460938,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,
range_id_query_btree,btree,"SELECT order_id, order_date, status FROM Orders WHERE order_id BETWEEN 5000 AND 5100;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.002354860305786133,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,
range_id_query_hash,hash,"SELECT order_id, order_date, status FROM Orders WHERE order_id BETWEEN 5000 AND 5100;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.004839181900024414,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,
range_id_query_bitmap,bitmap,"SELECT order_id, order_date, status FROM Orders WHERE order_id BETWEEN 5000 AND 5100;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.0057048797607421875,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,
range_id_query_gist,gist,"SELECT order_id, order_date, status FROM Orders WHERE order_id BETWEEN 5000 AND 5100;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0018973350524902344,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,
timestamp_query,reverse,"SELECT order_id, user_id, order_date, status FROM Orders WHERE order_date = '2024-03-15';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.031855106353759766,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
timestamp_query_btree,btree,"SELECT order_id, user_id, order_date, status FROM Orders WHERE order_date = '2024-03-15';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.005258798599243164,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
timestamp_query_hash,hash,"SELECT order_id, user_id, order_date, status FROM Orders WHERE order_date = '2024-03-15';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.025989294052124023,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
timestamp_query_bitmap,bitmap,"SELECT order_id, user_id, order_date, status FROM Orders WHERE order_date = '2024-03-15';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.026093006134033203,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
timestamp_query_gist,gist,"SELECT order_id, user_id, order_date, status FROM Orders WHERE order_date = '2024-03-15';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.005465030670166016,0.0,0.0,0.0,111.55078125,111.55078125,0.0,101,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
address_search,gist,"SELECT user_id, first_name, last_name, shipping_address FROM users WHERE shipping_address ILIKE '%New York%';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0063381195068359375,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
address_search_btree,btree,"SELECT user_id, first_name, last_name, shipping_address FROM users WHERE shipping_address ILIKE '%New York%';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.010158061981201172,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
address_search_hash,hash,"SELECT user_id, first_name, last_name, shipping_address FROM users WHERE shipping_address ILIKE '%New York%';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.011655569076538086,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
address_search_bitmap,bitmap,"SELECT user_id, first_name, last_name, shipping_address FROM users WHERE shipping_address ILIKE '%New York%';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.012314081192016602,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
address_search_reverse,reverse,"SELECT user_id, first_name, last_name, shipping_address FROM users WHERE shipping_address ILIKE '%New York%';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.009792566299438477,0.0,0.0,0.0,111.55078125,111.55078125,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,2,1,
complex_range_query,gist,"SELECT order_id, user_id, order_date, shipping_address FROM Orders WHERE shipping_address ILIKE '%usa%';  -- Changed to ILIKE for case-insensitive substring search",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.12761998176574707,0.0,0.0,0.0,111.55078125,111.58203125,0.03125,2436,1,0,0,0,0,0,0,0,1,0,0,0,0,0,4,2,
complex_range_query_btree,btree,"SELECT order_id, user_id, order_date, shipping_address FROM Orders WHERE shipping_address ILIKE '%usa%';  -- Changed to ILIKE for case-insensitive substring search",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.13187789916992188,0.0,0.0,0.0,111.58203125,111.58203125,0.0,2436,1,0,0,0,0,0,0,0,1,0,0,0,0,0,4,2,
complex_range_query_hash,hash,"SELECT order_id, user_id, order_date, shipping_address FROM Orders WHERE shipping_address ILIKE '%usa%';  -- Changed to ILIKE for case-insensitive substring search",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.16398096084594727,0.0,0.0,0.0,111.58203125,111.58203125,0.0,2436,1,0,0,0,0,0,0,0,1,0,0,0,0,0,4,2,
complex_range_query_bitmap,bitmap,"SELECT order_id, user_id, order_date, shipping_address FROM Orders WHERE shipping_address ILIKE '%usa%';  -- Changed to ILIKE for case-insensitive substring search",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.13137602806091309,0.0,0.0,0.0,111.58203125,111.58203125,0.0,2436,1,0,0,0,0,0,0,0,1,0,0,0,0,0,4,2,
complex_range_query_reverse,reverse,"SELECT order_id, user_id, order_date, shipping_address FROM Orders WHERE shipping_address ILIKE '%usa%';  -- Changed to ILIKE for case-insensitive substring search",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.12706422805786133,0.0,0.0,0.0,111.58203125,111.58203125,0.0,2436,1,0,0,0,0,0,0,0,1,0,0,0,0,0,4,2,
customer_location_search,gist,"SELECT u.user_id, u.first_name, u.last_name, u.shipping_address, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id WHERE u.shipping_address ILIKE '%California%' GROUP BY u.user_id, u.first_name, u.last_name, u.shipping_address;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0028150081634521484,0.0,0.0,0.0,110.58203125,110.58203125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,4,1,
customer_location_search_btree,btree,"SELECT u.user_id, u.first_name, u.last_name, u.shipping_address, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id WHERE u.shipping_address ILIKE '%California%' GROUP BY u.user_id, u.first_name, u.last_name, u.shipping_address;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.012300968170166016,0.0,0.0,0.0,110.58203125,110.58203125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,4,1,
customer_location_search_hash,hash,"SELECT u.user_id, u.first_name, u.last_name, u.shipping_address, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id WHERE u.shipping_address ILIKE '%California%' GROUP BY u.user_id, u.first_name, u.last_name, u.shipping_address;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.00909113883972168,0.0,0.0,0.0,110.58203125,110.58203125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,4,1,
customer_location_search_bitmap,bitmap,"SELECT u.user_id, u.first_name, u.last_name, u.shipping_address, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id WHERE u.shipping_address ILIKE '%California%' GROUP BY u.user_id, u.first_name, u.last_name, u.shipping_address;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.009731769561767578,0.0,0.0,0.0,110.58203125,110.58203125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,4,1,
customer_location_search_reverse,reverse,"SELECT u.user_id, u.first_name, u.last_name, u.shipping_address, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as total_spent FROM users u LEFT JOIN orders o ON u.user_id = o.user_id WHERE u.shipping_address ILIKE '%California%' GROUP BY u.user_id, u.first_name, u.last_name, u.shipping_address;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.012670278549194336,0.0,0.0,0.0,110.58203125,110.58203125,0.0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,4,1,
full_text_search,gist,"SELECT product_id, name, description FROM Products WHERE to_tsvector('english', description) @@ to_tsquery('english', 'oil');",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.04011344909667969,0.0,0.0,0.0,110.58203125,110.58203125,0.0,53,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
full_text_search_btree,btree,"SELECT product_id, name, description FROM Products WHERE to_tsvector('english', description) @@ to_tsquery('english', 'oil');",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.044927358627319336,0.0,0.0,0.0,110.5859375,110.5859375,0.0,53,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
full_text_search_hash,hash,"SELECT product_id, name, description FROM Products WHERE to_tsvector('english', description) @@ to_tsquery('english', 'oil');",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.04197525978088379,0.0,0.0,0.0,110.5859375,110.5859375,0.0,53,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
full_text_search_bitmap,bitmap,"SELECT product_id, name, description FROM Products WHERE to_tsvector('english', description) @@ to_tsquery('english', 'oil');",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.03883957862854004,0.0,0.0,0.0,110.5859375,110.5859375,0.0,53,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
full_text_search_reverse,reverse,"SELECT product_id, name, description FROM Products WHERE to_tsvector('english', description) @@ to_tsquery('english', 'oil');",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.04198026657104492,0.0,0.0,0.0,110.5859375,110.5859375,0.0,53,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
fuzzy_product_search,gist,"SELECT product_id, name, price FROM products WHERE name % 'wireless headphones';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.0020270347595214844,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
fuzzy_product_search_btree,btree,"SELECT product_id, name, price FROM products WHERE name % 'wireless headphones';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.00939631462097168,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
fuzzy_product_search_hash,hash,"SELECT product_id, name, price FROM products WHERE name % 'wireless headphones';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0055599212646484375,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
fuzzy_product_search_bitmap,bitmap,"SELECT product_id, name, price FROM products WHERE name % 'wireless headphones';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.00499725341796875,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
fuzzy_product_search_reverse,reverse,"SELECT product_id, name, price FROM products WHERE name % 'wireless headphones';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.005364894866943359,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
product_description_search,gist,"SELECT p.product_id, p.name, p.description, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.description ILIKE '%premium%' OR p.description ILIKE '%quality%' ORDER BY p.price DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.008831501007080078,0.0,0.0,0.0,110.5859375,110.5859375,0.0,46,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,2,
product_description_search_btree,btree,"SELECT p.product_id, p.name, p.description, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.description ILIKE '%premium%' OR p.description ILIKE '%quality%' ORDER BY p.price DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.008538484573364258,0.0,0.0,0.0,110.5859375,110.5859375,0.0,46,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,2,
product_description_search_hash,hash,"SELECT p.product_id, p.name, p.description, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.description ILIKE '%premium%' OR p.description ILIKE '%quality%' ORDER BY p.price DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.009554862976074219,0.0,0.0,0.0,110.5859375,110.5859375,0.0,46,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,2,
product_description_search_bitmap,bitmap,"SELECT p.product_id, p.name, p.description, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.description ILIKE '%premium%' OR p.description ILIKE '%quality%' ORDER BY p.price DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.011312007904052734,0.0,0.0,0.0,110.5859375,110.5859375,0.0,46,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,2,
product_description_search_reverse,reverse,"SELECT p.product_id, p.name, p.description, p.price, c.name as category FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.description ILIKE '%premium%' OR p.description ILIKE '%quality%' ORDER BY p.price DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.012065649032592773,0.0,0.0,0.0,110.5859375,110.5859375,0.0,46,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,2,
product_search,gist,"SELECT product_id, name, description, price FROM products WHERE name ILIKE '%wireless%' OR description ILIKE '%wireless%';",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.006645917892456055,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,
product_search_btree,btree,"SELECT product_id, name, description, price FROM products WHERE name ILIKE '%wireless%' OR description ILIKE '%wireless%';",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.008721113204956055,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,
product_search_hash,hash,"SELECT product_id, name, description, price FROM products WHERE name ILIKE '%wireless%' OR description ILIKE '%wireless%';",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.005933523178100586,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,
product_search_bitmap,bitmap,"SELECT product_id, name, description, price FROM products WHERE name ILIKE '%wireless%' OR description ILIKE '%wireless%';",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.008515119552612305,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,
product_search_reverse,reverse,"SELECT product_id, name, description, price FROM products WHERE name ILIKE '%wireless%' OR description ILIKE '%wireless%';",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.008951902389526367,0.0,0.0,0.0,110.5859375,110.5859375,0.0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,
similar_category_products,gist,"SELECT DISTINCT p1.name as product1, p2.name as product2, p1.price as price1, p2.price as price2, similarity(p1.name, p2.name) as name_similarity FROM products p1 JOIN products p2 ON p1.category_id = p2.category_id AND p1.product_id < p2.product_id WHERE similarity(p1.name, p2.name) > 0.4 ORDER BY name_similarity DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.13338065147399902,0.0,0.0,0.0,110.5859375,110.5859375,0.0,47,1,0,0,0,0,0,0,1,1,0,1,0,0,0,2,0,
similar_category_products_btree,btree,"SELECT DISTINCT p1.name as product1, p2.name as product2, p1.price as price1, p2.price as price2, similarity(p1.name, p2.name) as name_similarity FROM products p1 JOIN products p2 ON p1.category_id = p2.category_id AND p1.product_id < p2.product_id WHERE similarity(p1.name, p2.name) > 0.4 ORDER BY name_similarity DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.138932466506958,0.0,0.0,0.0,110.5859375,110.5859375,0.0,47,1,0,0,0,0,0,0,1,1,0,1,0,0,0,2,0,
similar_category_products_hash,hash,"SELECT DISTINCT p1.name as product1, p2.name as product2, p1.price as price1, p2.price as price2, similarity(p1.name, p2.name) as name_similarity FROM products p1 JOIN products p2 ON p1.category_id = p2.category_id AND p1.product_id < p2.product_id WHERE similarity(p1.name, p2.name) > 0.4 ORDER BY name_similarity DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.1330699920654297,0.0,0.0,0.0,110.5859375,110.5859375,0.0,47,1,0,0,0,0,0,0,1,1,0,1,0,0,0,2,0,
similar_category_products_bitmap,bitmap,"SELECT DISTINCT p1.name as product1, p2.name as product2, p1.price as price1, p2.price as price2, similarity(p1.name, p2.name) as name_similarity FROM products p1 JOIN products p2 ON p1.category_id = p2.category_id AND p1.product_id < p2.product_id WHERE similarity(p1.name, p2.name) > 0.4 ORDER BY name_similarity DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.1335127353668213,0.0,0.0,0.0,110.5859375,110.5859375,0.0,47,1,0,0,0,0,0,0,1,1,0,1,0,0,0,2,0,
similar_category_products_reverse,reverse,"SELECT DISTINCT p1.name as product1, p2.name as product2, p1.price as price1, p2.price as price2, similarity(p1.name, p2.name) as name_similarity FROM products p1 JOIN products p2 ON p1.category_id = p2.category_id AND p1.product_id < p2.product_id WHERE similarity(p1.name, p2.name) > 0.4 ORDER BY name_similarity DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.13616085052490234,0.0,0.0,0.0,110.5859375,110.5859375,0.0,47,1,0,0,0,0,0,0,1,1,0,1,0,0,0,2,0,
similar_products,gist,"SELECT p1.product_id, p1.name, p1.description FROM products p1, products p2 WHERE p1.product_id != p2.product_id AND similarity(p1.name, p2.name) > 0.3 ORDER BY similarity(p1.name, p2.name) DESC;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),4.770925045013428,0.0,0.0,0.0,110.5859375,110.984375,0.3984375,3848,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,
similar_products_btree,btree,"SELECT p1.product_id, p1.name, p1.description FROM products p1, products p2 WHERE p1.product_id != p2.product_id AND similarity(p1.name, p2.name) > 0.3 ORDER BY similarity(p1.name, p2.name) DESC;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),4.7424845695495605,0.0,0.0,0.0,110.984375,110.984375,0.0,3848,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,
similar_products_hash,hash,"SELECT p1.product_id, p1.name, p1.description FROM products p1, products p2 WHERE p1.product_id != p2.product_id AND similarity(p1.name, p2.name) > 0.3 ORDER BY similarity(p1.name, p2.name) DESC;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),4.755443334579468,0.0,0.0,0.0,110.984375,110.9765625,-0.0078125,3848,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,
similar_products_bitmap,bitmap,"SELECT p1.product_id, p1.name, p1.description FROM products p1, products p2 WHERE p1.product_id != p2.product_id AND similarity(p1.name, p2.name) > 0.3 ORDER BY similarity(p1.name, p2.name) DESC;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),4.811589956283569,0.0,0.0,0.0,110.9765625,110.9765625,0.0,3848,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,
similar_products_reverse,reverse,"SELECT p1.product_id, p1.name, p1.description FROM products p1, products p2 WHERE p1.product_id != p2.product_id AND similarity(p1.name, p2.name) > 0.3 ORDER BY similarity(p1.name, p2.name) DESC;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),4.7479612827301025,0.0,0.0,0.0,110.9765625,110.9765625,0.0,3848,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,
trigram_match,gist,"select * from (SELECT product_id, name, description FROM Products WHERE 'heavy' % name) pind;",GiST index for complex data types,CREATE INDEX gist_orders_date ON Orders USING GIST (order_date); CREATE INDEX gist_products_name ON Products USING GIST (name gist_trgm_ops); CREATE INDEX gist_users_address ON Users USING GIST (shipping_address gist_trgm_ops),0.004139900207519531,0.0,0.0,0.0,110.9765625,110.9765625,0.0,3,2,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
trigram_match_btree,btree,"select * from (SELECT product_id, name, description FROM Products WHERE 'heavy' % name) pind;",B-Tree index for range queries and sorting,CREATE INDEX btree_orders_date ON Orders (order_date); CREATE INDEX btree_orders_user ON Orders (user_id); CREATE INDEX btree_products_category ON Products (category_id); CREATE INDEX btree_orderitems_order ON OrderItems (order_id); CREATE INDEX btree_orderitems_product ON OrderItems (product_id),0.007641315460205078,0.0,0.0,0.0,110.9765625,110.9765625,0.0,3,2,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
trigram_match_hash,hash,"select * from (SELECT product_id, name, description FROM Products WHERE 'heavy' % name) pind;",Hash index for equality comparisons,CREATE INDEX hash_users_email ON Users USING HASH (email); CREATE INDEX hash_products_id ON Products USING HASH (product_id); CREATE INDEX hash_orders_id ON Orders USING HASH (order_id),0.0036106109619140625,0.0,0.0,0.0,110.9765625,110.9765625,0.0,3,2,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
trigram_match_bitmap,bitmap,"select * from (SELECT product_id, name, description FROM Products WHERE 'heavy' % name) pind;",Bitmap index for low-cardinality columns,CREATE INDEX bitmap_orders_status ON Orders (status); CREATE INDEX bitmap_products_category ON Products (category_id); CREATE INDEX bitmap_categories_parent ON Categories (category_id),0.003987312316894531,0.0,0.0,0.0,110.9765625,110.9765625,0.0,3,2,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
trigram_match_reverse,reverse,"select * from (SELECT product_id, name, description FROM Products WHERE 'heavy' % name) pind;",Reverse index for reducing concurrency contention,CREATE INDEX rev_users_id ON Users USING REVERSE (user_id); CREATE INDEX rev_orders_date ON Orders USING REVERSE (order_date); CREATE INDEX rev_products_name ON Products USING REVERSE (name),0.004511833190917969,0.0,0.0,0.0,110.9765625,110.9765625,0.0,3,2,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
